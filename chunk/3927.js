"use strict";(self.webpackJsonp=self.webpackJsonp||[]).push([[3927],{"3927":function(e){e.exports=JSON.parse('{"version":3,"sources":["../../node_modules/.pnpm/registry.npmjs.org+intersection-observer@0.7.0/node_modules/intersection-observer/intersection-observer.js"],"names":["window","IntersectionObserverEntry","prototype","Object","defineProperty","get","this","intersectionRatio","document","entry","time","target","rootBounds","boundingClientRect","intersectionRect","getEmptyRect","isIntersecting","targetRect","targetArea","width","height","intersectionArea","Number","toFixed","IntersectionObserver","callback","opt_options","options","Error","root","nodeType","_checkForIntersections","throttle","bind","THROTTLE_TIMEOUT","_callback","_observationTargets","_queuedEntries","_rootMarginValues","_parseRootMargin","rootMargin","thresholds","_initThresholds","threshold","map","margin","value","unit","join","POLL_INTERVAL","USE_MUTATION_OBSERVER","observe","isTargetAlreadyObserved","some","item","element","_registerInstance","push","_monitorIntersections","unobserve","filter","length","_unmonitorIntersections","_unregisterInstance","disconnect","takeRecords","records","slice","opt_threshold","Array","isArray","sort","t","i","a","isNaN","opt_rootMargin","marginString","margins","split","parts","exec","parseFloat","_monitoringIntersections","_monitoringInterval","setInterval","addEvent","_domObserver","MutationObserver","attributes","childList","characterData","subtree","clearInterval","removeEvent","rootIsInDom","_rootIsInDom","rootRect","_getRootRect","forEach","getBoundingClientRect","rootContainsTarget","_rootContainsTarget","oldEntry","_computeTargetAndRootIntersection","newEntry","now","_hasCrossedThreshold","getComputedStyle","display","parent","getParentNode","atRoot","parentRect","parentComputedStyle","body","documentElement","overflow","computeRectIntersection","html","top","left","right","clientWidth","bottom","clientHeight","_expandRectByRootMargin","rect","newRect","oldRatio","newRatio","containsDeep","performance","fn","timeout","timer","setTimeout","node","event","opt_useCapture","addEventListener","attachEvent","removeEventListener","detatchEvent","rect1","rect2","Math","max","min","el","err","child","parentNode","host","assignedSlot"],"mappings":"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","sourcesContent":["/**\\n * Copyright 2016 Google Inc. All Rights Reserved.\\n *\\n * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\\n *\\n *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\\n *\\n */\\n(function() {\\n\'use strict\';\\n\\n// Exit early if we\'re not running in a browser.\\nif (typeof window !== \'object\') {\\n  return;\\n}\\n\\n// Exit early if all IntersectionObserver and IntersectionObserverEntry\\n// features are natively supported.\\nif (\'IntersectionObserver\' in window &&\\n    \'IntersectionObserverEntry\' in window &&\\n    \'intersectionRatio\' in window.IntersectionObserverEntry.prototype) {\\n\\n  // Minimal polyfill for Edge 15\'s lack of `isIntersecting`\\n  // See: https://github.com/w3c/IntersectionObserver/issues/211\\n  if (!(\'isIntersecting\' in window.IntersectionObserverEntry.prototype)) {\\n    Object.defineProperty(window.IntersectionObserverEntry.prototype,\\n      \'isIntersecting\', {\\n      get: function () {\\n        return this.intersectionRatio > 0;\\n      }\\n    });\\n  }\\n  return;\\n}\\n\\n\\n/**\\n * A local reference to the document.\\n */\\nvar document = window.document;\\n\\n\\n/**\\n * An IntersectionObserver registry. This registry exists to hold a strong\\n * reference to IntersectionObserver instances currently observing a target\\n * element. Without this registry, instances without another reference may be\\n * garbage collected.\\n */\\nvar registry = [];\\n\\n\\n/**\\n * Creates the global IntersectionObserverEntry constructor.\\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\\n * @param {Object} entry A dictionary of instance properties.\\n * @constructor\\n */\\nfunction IntersectionObserverEntry(entry) {\\n  this.time = entry.time;\\n  this.target = entry.target;\\n  this.rootBounds = entry.rootBounds;\\n  this.boundingClientRect = entry.boundingClientRect;\\n  this.intersectionRect = entry.intersectionRect || getEmptyRect();\\n  this.isIntersecting = !!entry.intersectionRect;\\n\\n  // Calculates the intersection ratio.\\n  var targetRect = this.boundingClientRect;\\n  var targetArea = targetRect.width * targetRect.height;\\n  var intersectionRect = this.intersectionRect;\\n  var intersectionArea = intersectionRect.width * intersectionRect.height;\\n\\n  // Sets intersection ratio.\\n  if (targetArea) {\\n    // Round the intersection ratio to avoid floating point math issues:\\n    // https://github.com/w3c/IntersectionObserver/issues/324\\n    this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));\\n  } else {\\n    // If area is zero and is intersecting, sets to 1, otherwise to 0\\n    this.intersectionRatio = this.isIntersecting ? 1 : 0;\\n  }\\n}\\n\\n\\n/**\\n * Creates the global IntersectionObserver constructor.\\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\\n * @param {Function} callback The function to be invoked after intersection\\n *     changes have queued. The function is not invoked if the queue has\\n *     been emptied by calling the `takeRecords` method.\\n * @param {Object=} opt_options Optional configuration options.\\n * @constructor\\n */\\nfunction IntersectionObserver(callback, opt_options) {\\n\\n  var options = opt_options || {};\\n\\n  if (typeof callback != \'function\') {\\n    throw new Error(\'callback must be a function\');\\n  }\\n\\n  if (options.root && options.root.nodeType != 1) {\\n    throw new Error(\'root must be an Element\');\\n  }\\n\\n  // Binds and throttles `this._checkForIntersections`.\\n  this._checkForIntersections = throttle(\\n      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\\n\\n  // Private properties.\\n  this._callback = callback;\\n  this._observationTargets = [];\\n  this._queuedEntries = [];\\n  this._rootMarginValues = this._parseRootMargin(options.rootMargin);\\n\\n  // Public properties.\\n  this.thresholds = this._initThresholds(options.threshold);\\n  this.root = options.root || null;\\n  this.rootMargin = this._rootMarginValues.map(function(margin) {\\n    return margin.value + margin.unit;\\n  }).join(\' \');\\n}\\n\\n\\n/**\\n * The minimum interval within which the document will be checked for\\n * intersection changes.\\n */\\nIntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\\n\\n\\n/**\\n * The frequency in which the polyfill polls for intersection changes.\\n * this can be updated on a per instance basis and must be set prior to\\n * calling `observe` on the first target.\\n */\\nIntersectionObserver.prototype.POLL_INTERVAL = null;\\n\\n/**\\n * Use a mutation observer on the root element\\n * to detect intersection changes.\\n */\\nIntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\\n\\n\\n/**\\n * Starts observing a target element for intersection changes based on\\n * the thresholds values.\\n * @param {Element} target The DOM element to observe.\\n */\\nIntersectionObserver.prototype.observe = function(target) {\\n  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {\\n    return item.element == target;\\n  });\\n\\n  if (isTargetAlreadyObserved) {\\n    return;\\n  }\\n\\n  if (!(target && target.nodeType == 1)) {\\n    throw new Error(\'target must be an Element\');\\n  }\\n\\n  this._registerInstance();\\n  this._observationTargets.push({element: target, entry: null});\\n  this._monitorIntersections();\\n  this._checkForIntersections();\\n};\\n\\n\\n/**\\n * Stops observing a target element for intersection changes.\\n * @param {Element} target The DOM element to observe.\\n */\\nIntersectionObserver.prototype.unobserve = function(target) {\\n  this._observationTargets =\\n      this._observationTargets.filter(function(item) {\\n\\n    return item.element != target;\\n  });\\n  if (!this._observationTargets.length) {\\n    this._unmonitorIntersections();\\n    this._unregisterInstance();\\n  }\\n};\\n\\n\\n/**\\n * Stops observing all target elements for intersection changes.\\n */\\nIntersectionObserver.prototype.disconnect = function() {\\n  this._observationTargets = [];\\n  this._unmonitorIntersections();\\n  this._unregisterInstance();\\n};\\n\\n\\n/**\\n * Returns any queue entries that have not yet been reported to the\\n * callback and clears the queue. This can be used in conjunction with the\\n * callback to obtain the absolute most up-to-date intersection information.\\n * @return {Array} The currently queued entries.\\n */\\nIntersectionObserver.prototype.takeRecords = function() {\\n  var records = this._queuedEntries.slice();\\n  this._queuedEntries = [];\\n  return records;\\n};\\n\\n\\n/**\\n * Accepts the threshold value from the user configuration object and\\n * returns a sorted array of unique threshold values. If a value is not\\n * between 0 and 1 and error is thrown.\\n * @private\\n * @param {Array|number=} opt_threshold An optional threshold value or\\n *     a list of threshold values, defaulting to [0].\\n * @return {Array} A sorted list of unique and valid threshold values.\\n */\\nIntersectionObserver.prototype._initThresholds = function(opt_threshold) {\\n  var threshold = opt_threshold || [0];\\n  if (!Array.isArray(threshold)) threshold = [threshold];\\n\\n  return threshold.sort().filter(function(t, i, a) {\\n    if (typeof t != \'number\' || isNaN(t) || t < 0 || t > 1) {\\n      throw new Error(\'threshold must be a number between 0 and 1 inclusively\');\\n    }\\n    return t !== a[i - 1];\\n  });\\n};\\n\\n\\n/**\\n * Accepts the rootMargin value from the user configuration object\\n * and returns an array of the four margin values as an object containing\\n * the value and unit properties. If any of the values are not properly\\n * formatted or use a unit other than px or %, and error is thrown.\\n * @private\\n * @param {string=} opt_rootMargin An optional rootMargin value,\\n *     defaulting to \'0px\'.\\n * @return {Array<Object>} An array of margin objects with the keys\\n *     value and unit.\\n */\\nIntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\\n  var marginString = opt_rootMargin || \'0px\';\\n  var margins = marginString.split(/\\\\s+/).map(function(margin) {\\n    var parts = /^(-?\\\\d*\\\\.?\\\\d+)(px|%)$/.exec(margin);\\n    if (!parts) {\\n      throw new Error(\'rootMargin must be specified in pixels or percent\');\\n    }\\n    return {value: parseFloat(parts[1]), unit: parts[2]};\\n  });\\n\\n  // Handles shorthand.\\n  margins[1] = margins[1] || margins[0];\\n  margins[2] = margins[2] || margins[0];\\n  margins[3] = margins[3] || margins[1];\\n\\n  return margins;\\n};\\n\\n\\n/**\\n * Starts polling for intersection changes if the polling is not already\\n * happening, and if the page\'s visibility state is visible.\\n * @private\\n */\\nIntersectionObserver.prototype._monitorIntersections = function() {\\n  if (!this._monitoringIntersections) {\\n    this._monitoringIntersections = true;\\n\\n    // If a poll interval is set, use polling instead of listening to\\n    // resize and scroll events or DOM mutations.\\n    if (this.POLL_INTERVAL) {\\n      this._monitoringInterval = setInterval(\\n          this._checkForIntersections, this.POLL_INTERVAL);\\n    }\\n    else {\\n      addEvent(window, \'resize\', this._checkForIntersections, true);\\n      addEvent(document, \'scroll\', this._checkForIntersections, true);\\n\\n      if (this.USE_MUTATION_OBSERVER && \'MutationObserver\' in window) {\\n        this._domObserver = new MutationObserver(this._checkForIntersections);\\n        this._domObserver.observe(document, {\\n          attributes: true,\\n          childList: true,\\n          characterData: true,\\n          subtree: true\\n        });\\n      }\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Stops polling for intersection changes.\\n * @private\\n */\\nIntersectionObserver.prototype._unmonitorIntersections = function() {\\n  if (this._monitoringIntersections) {\\n    this._monitoringIntersections = false;\\n\\n    clearInterval(this._monitoringInterval);\\n    this._monitoringInterval = null;\\n\\n    removeEvent(window, \'resize\', this._checkForIntersections, true);\\n    removeEvent(document, \'scroll\', this._checkForIntersections, true);\\n\\n    if (this._domObserver) {\\n      this._domObserver.disconnect();\\n      this._domObserver = null;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Scans each observation target for intersection changes and adds them\\n * to the internal entries queue. If new entries are found, it\\n * schedules the callback to be invoked.\\n * @private\\n */\\nIntersectionObserver.prototype._checkForIntersections = function() {\\n  var rootIsInDom = this._rootIsInDom();\\n  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\\n\\n  this._observationTargets.forEach(function(item) {\\n    var target = item.element;\\n    var targetRect = getBoundingClientRect(target);\\n    var rootContainsTarget = this._rootContainsTarget(target);\\n    var oldEntry = item.entry;\\n    var intersectionRect = rootIsInDom && rootContainsTarget &&\\n        this._computeTargetAndRootIntersection(target, rootRect);\\n\\n    var newEntry = item.entry = new IntersectionObserverEntry({\\n      time: now(),\\n      target: target,\\n      boundingClientRect: targetRect,\\n      rootBounds: rootRect,\\n      intersectionRect: intersectionRect\\n    });\\n\\n    if (!oldEntry) {\\n      this._queuedEntries.push(newEntry);\\n    } else if (rootIsInDom && rootContainsTarget) {\\n      // If the new entry intersection ratio has crossed any of the\\n      // thresholds, add a new entry.\\n      if (this._hasCrossedThreshold(oldEntry, newEntry)) {\\n        this._queuedEntries.push(newEntry);\\n      }\\n    } else {\\n      // If the root is not in the DOM or target is not contained within\\n      // root but the previous entry for this target had an intersection,\\n      // add a new record indicating removal.\\n      if (oldEntry && oldEntry.isIntersecting) {\\n        this._queuedEntries.push(newEntry);\\n      }\\n    }\\n  }, this);\\n\\n  if (this._queuedEntries.length) {\\n    this._callback(this.takeRecords(), this);\\n  }\\n};\\n\\n\\n/**\\n * Accepts a target and root rect computes the intersection between then\\n * following the algorithm in the spec.\\n * TODO(philipwalton): at this time clip-path is not considered.\\n * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\\n * @param {Element} target The target DOM element\\n * @param {Object} rootRect The bounding rect of the root after being\\n *     expanded by the rootMargin value.\\n * @return {?Object} The final intersection rect object or undefined if no\\n *     intersection is found.\\n * @private\\n */\\nIntersectionObserver.prototype._computeTargetAndRootIntersection =\\n    function(target, rootRect) {\\n\\n  // If the element isn\'t displayed, an intersection can\'t happen.\\n  if (window.getComputedStyle(target).display == \'none\') return;\\n\\n  var targetRect = getBoundingClientRect(target);\\n  var intersectionRect = targetRect;\\n  var parent = getParentNode(target);\\n  var atRoot = false;\\n\\n  while (!atRoot) {\\n    var parentRect = null;\\n    var parentComputedStyle = parent.nodeType == 1 ?\\n        window.getComputedStyle(parent) : {};\\n\\n    // If the parent isn\'t displayed, an intersection can\'t happen.\\n    if (parentComputedStyle.display == \'none\') return;\\n\\n    if (parent == this.root || parent == document) {\\n      atRoot = true;\\n      parentRect = rootRect;\\n    } else {\\n      // If the element has a non-visible overflow, and it\'s not the <body>\\n      // or <html> element, update the intersection rect.\\n      // Note: <body> and <html> cannot be clipped to a rect that\'s not also\\n      // the document rect, so no need to compute a new intersection.\\n      if (parent != document.body &&\\n          parent != document.documentElement &&\\n          parentComputedStyle.overflow != \'visible\') {\\n        parentRect = getBoundingClientRect(parent);\\n      }\\n    }\\n\\n    // If either of the above conditionals set a new parentRect,\\n    // calculate new intersection data.\\n    if (parentRect) {\\n      intersectionRect = computeRectIntersection(parentRect, intersectionRect);\\n\\n      if (!intersectionRect) break;\\n    }\\n    parent = getParentNode(parent);\\n  }\\n  return intersectionRect;\\n};\\n\\n\\n/**\\n * Returns the root rect after being expanded by the rootMargin value.\\n * @return {Object} The expanded root rect.\\n * @private\\n */\\nIntersectionObserver.prototype._getRootRect = function() {\\n  var rootRect;\\n  if (this.root) {\\n    rootRect = getBoundingClientRect(this.root);\\n  } else {\\n    // Use <html>/<body> instead of window since scroll bars affect size.\\n    var html = document.documentElement;\\n    var body = document.body;\\n    rootRect = {\\n      top: 0,\\n      left: 0,\\n      right: html.clientWidth || body.clientWidth,\\n      width: html.clientWidth || body.clientWidth,\\n      bottom: html.clientHeight || body.clientHeight,\\n      height: html.clientHeight || body.clientHeight\\n    };\\n  }\\n  return this._expandRectByRootMargin(rootRect);\\n};\\n\\n\\n/**\\n * Accepts a rect and expands it by the rootMargin value.\\n * @param {Object} rect The rect object to expand.\\n * @return {Object} The expanded rect.\\n * @private\\n */\\nIntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\\n  var margins = this._rootMarginValues.map(function(margin, i) {\\n    return margin.unit == \'px\' ? margin.value :\\n        margin.value * (i % 2 ? rect.width : rect.height) / 100;\\n  });\\n  var newRect = {\\n    top: rect.top - margins[0],\\n    right: rect.right + margins[1],\\n    bottom: rect.bottom + margins[2],\\n    left: rect.left - margins[3]\\n  };\\n  newRect.width = newRect.right - newRect.left;\\n  newRect.height = newRect.bottom - newRect.top;\\n\\n  return newRect;\\n};\\n\\n\\n/**\\n * Accepts an old and new entry and returns true if at least one of the\\n * threshold values has been crossed.\\n * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\\n *    particular target element or null if no previous entry exists.\\n * @param {IntersectionObserverEntry} newEntry The current entry for a\\n *    particular target element.\\n * @return {boolean} Returns true if a any threshold has been crossed.\\n * @private\\n */\\nIntersectionObserver.prototype._hasCrossedThreshold =\\n    function(oldEntry, newEntry) {\\n\\n  // To make comparing easier, an entry that has a ratio of 0\\n  // but does not actually intersect is given a value of -1\\n  var oldRatio = oldEntry && oldEntry.isIntersecting ?\\n      oldEntry.intersectionRatio || 0 : -1;\\n  var newRatio = newEntry.isIntersecting ?\\n      newEntry.intersectionRatio || 0 : -1;\\n\\n  // Ignore unchanged ratios\\n  if (oldRatio === newRatio) return;\\n\\n  for (var i = 0; i < this.thresholds.length; i++) {\\n    var threshold = this.thresholds[i];\\n\\n    // Return true if an entry matches a threshold or if the new ratio\\n    // and the old ratio are on the opposite sides of a threshold.\\n    if (threshold == oldRatio || threshold == newRatio ||\\n        threshold < oldRatio !== threshold < newRatio) {\\n      return true;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Returns whether or not the root element is an element and is in the DOM.\\n * @return {boolean} True if the root element is an element and is in the DOM.\\n * @private\\n */\\nIntersectionObserver.prototype._rootIsInDom = function() {\\n  return !this.root || containsDeep(document, this.root);\\n};\\n\\n\\n/**\\n * Returns whether or not the target element is a child of root.\\n * @param {Element} target The target element to check.\\n * @return {boolean} True if the target element is a child of root.\\n * @private\\n */\\nIntersectionObserver.prototype._rootContainsTarget = function(target) {\\n  return containsDeep(this.root || document, target);\\n};\\n\\n\\n/**\\n * Adds the instance to the global IntersectionObserver registry if it isn\'t\\n * already present.\\n * @private\\n */\\nIntersectionObserver.prototype._registerInstance = function() {\\n  if (registry.indexOf(this) < 0) {\\n    registry.push(this);\\n  }\\n};\\n\\n\\n/**\\n * Removes the instance from the global IntersectionObserver registry.\\n * @private\\n */\\nIntersectionObserver.prototype._unregisterInstance = function() {\\n  var index = registry.indexOf(this);\\n  if (index != -1) registry.splice(index, 1);\\n};\\n\\n\\n/**\\n * Returns the result of the performance.now() method or null in browsers\\n * that don\'t support the API.\\n * @return {number} The elapsed time since the page was requested.\\n */\\nfunction now() {\\n  return window.performance && performance.now && performance.now();\\n}\\n\\n\\n/**\\n * Throttles a function and delays its execution, so it\'s only called at most\\n * once within a given time period.\\n * @param {Function} fn The function to throttle.\\n * @param {number} timeout The amount of time that must pass before the\\n *     function can be called again.\\n * @return {Function} The throttled function.\\n */\\nfunction throttle(fn, timeout) {\\n  var timer = null;\\n  return function () {\\n    if (!timer) {\\n      timer = setTimeout(function() {\\n        fn();\\n        timer = null;\\n      }, timeout);\\n    }\\n  };\\n}\\n\\n\\n/**\\n * Adds an event handler to a DOM node ensuring cross-browser compatibility.\\n * @param {Node} node The DOM node to add the event handler to.\\n * @param {string} event The event name.\\n * @param {Function} fn The event handler to add.\\n * @param {boolean} opt_useCapture Optionally adds the even to the capture\\n *     phase. Note: this only works in modern browsers.\\n */\\nfunction addEvent(node, event, fn, opt_useCapture) {\\n  if (typeof node.addEventListener == \'function\') {\\n    node.addEventListener(event, fn, opt_useCapture || false);\\n  }\\n  else if (typeof node.attachEvent == \'function\') {\\n    node.attachEvent(\'on\' + event, fn);\\n  }\\n}\\n\\n\\n/**\\n * Removes a previously added event handler from a DOM node.\\n * @param {Node} node The DOM node to remove the event handler from.\\n * @param {string} event The event name.\\n * @param {Function} fn The event handler to remove.\\n * @param {boolean} opt_useCapture If the event handler was added with this\\n *     flag set to true, it should be set to true here in order to remove it.\\n */\\nfunction removeEvent(node, event, fn, opt_useCapture) {\\n  if (typeof node.removeEventListener == \'function\') {\\n    node.removeEventListener(event, fn, opt_useCapture || false);\\n  }\\n  else if (typeof node.detatchEvent == \'function\') {\\n    node.detatchEvent(\'on\' + event, fn);\\n  }\\n}\\n\\n\\n/**\\n * Returns the intersection between two rect objects.\\n * @param {Object} rect1 The first rect.\\n * @param {Object} rect2 The second rect.\\n * @return {?Object} The intersection rect or undefined if no intersection\\n *     is found.\\n */\\nfunction computeRectIntersection(rect1, rect2) {\\n  var top = Math.max(rect1.top, rect2.top);\\n  var bottom = Math.min(rect1.bottom, rect2.bottom);\\n  var left = Math.max(rect1.left, rect2.left);\\n  var right = Math.min(rect1.right, rect2.right);\\n  var width = right - left;\\n  var height = bottom - top;\\n\\n  return (width >= 0 && height >= 0) && {\\n    top: top,\\n    bottom: bottom,\\n    left: left,\\n    right: right,\\n    width: width,\\n    height: height\\n  };\\n}\\n\\n\\n/**\\n * Shims the native getBoundingClientRect for compatibility with older IE.\\n * @param {Element} el The element whose bounding rect to get.\\n * @return {Object} The (possibly shimmed) rect of the element.\\n */\\nfunction getBoundingClientRect(el) {\\n  var rect;\\n\\n  try {\\n    rect = el.getBoundingClientRect();\\n  } catch (err) {\\n    // Ignore Windows 7 IE11 \\"Unspecified error\\"\\n    // https://github.com/w3c/IntersectionObserver/pull/205\\n  }\\n\\n  if (!rect) return getEmptyRect();\\n\\n  // Older IE\\n  if (!(rect.width && rect.height)) {\\n    rect = {\\n      top: rect.top,\\n      right: rect.right,\\n      bottom: rect.bottom,\\n      left: rect.left,\\n      width: rect.right - rect.left,\\n      height: rect.bottom - rect.top\\n    };\\n  }\\n  return rect;\\n}\\n\\n\\n/**\\n * Returns an empty rect object. An empty rect is returned when an element\\n * is not in the DOM.\\n * @return {Object} The empty rect.\\n */\\nfunction getEmptyRect() {\\n  return {\\n    top: 0,\\n    bottom: 0,\\n    left: 0,\\n    right: 0,\\n    width: 0,\\n    height: 0\\n  };\\n}\\n\\n/**\\n * Checks to see if a parent element contains a child element (including inside\\n * shadow DOM).\\n * @param {Node} parent The parent element.\\n * @param {Node} child The child element.\\n * @return {boolean} True if the parent node contains the child node.\\n */\\nfunction containsDeep(parent, child) {\\n  var node = child;\\n  while (node) {\\n    if (node == parent) return true;\\n\\n    node = getParentNode(node);\\n  }\\n  return false;\\n}\\n\\n\\n/**\\n * Gets the parent node of an element or its host element if the parent node\\n * is a shadow root.\\n * @param {Node} node The node whose parent to get.\\n * @return {Node|null} The parent node or null if no parent exists.\\n */\\nfunction getParentNode(node) {\\n  var parent = node.parentNode;\\n\\n  if (parent && parent.nodeType == 11 && parent.host) {\\n    // If the parent is a shadow root, return the host element.\\n    return parent.host;\\n  }\\n\\n  if (parent && parent.assignedSlot) {\\n    // If the parent is distributed in a <slot>, return the parent of a slot.\\n    return parent.assignedSlot.parentNode;\\n  }\\n\\n  return parent;\\n}\\n\\n\\n// Exposes the constructors globally.\\nwindow.IntersectionObserver = IntersectionObserver;\\nwindow.IntersectionObserverEntry = IntersectionObserverEntry;\\n\\n}());\\n"]}')}}]);