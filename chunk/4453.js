"use strict";(self.webpackJsonp=self.webpackJsonp||[]).push([[4453],{"4453":function(e){e.exports=JSON.parse('{"version":3,"sources":["@stencil/core/internal/app-data","../../node_modules/.pnpm/registry.npmjs.org+@stencil+core@2.19.2/node_modules/@stencil/core/internal/client/index.js?app-data=conditional"],"names":["NAMESPACE","contentRef","hostTagName","useNativeShadowDom","checkSlotFallbackVisibility","checkSlotRelocate","isSvgMode","queuePending","createTime","fnName","tagName","uniqueTime","key","measureText","HYDRATED_CSS","XLINK_NS","EMPTY_OBJ","isComplexType","o","h","nodeName","vnodeData","children","_i","arguments","length","child","slotName","simple","lastSimple","vNodeChildren","walk","c","i","Array","isArray","String","$text$","push","newVNode","name","classData_1","className","class","Object","keys","filter","k","join","vdomFnUtils","vnode","$attrs$","$children$","$key$","$name$","tag","text","$flags$","$tag$","$elm$","Host","isHost","node","forEach","cb","map","convertToPublic","convertToPrivate","vattrs","vchildren","vkey","vname","vtag","vtext","assign","apply","__spreadArray","parsePropertyValue","propValue","propType","parseFloat","getElement","ref","getHostRef","createEvent","flags","elm","emit","detail","emitEvent","bubbles","composed","cancelable","opts","ev","plt","ce","dispatchEvent","rootAppliedStyles","WeakMap","registerStyle","scopeId","cssText","allowCS","style","styles","get","supportsConstructableStylesheets","CSSStyleSheet","replaceSync","set","addStyle","styleContainerNode","cmpMeta","mode","hostElm","getScopeId","nodeType","doc","head","appliedStyles","styleElm","Set","has","createElement","innerHTML","insertBefore","querySelector","add","adoptedStyleSheets","includes","attachStyles","hostRef","$cmpMeta$","$hostElement$","endAttachStyles","$tagName$","getRootNode","cmp","setAccessor","memberName","oldValue","newValue","isSvg","isProp","isMemberInElement","ln","toLowerCase","classList","oldClasses_1","parseClassList","newClasses_1","remove","prop","removeProperty","setProperty","slice","win","rel","ael","isComplex","n","e","xlink","replace","getAttribute","removeAttributeNS","removeAttribute","setAttributeNS","setAttribute","parseClassListRegex","value","split","updateElement","oldVnode","newVnode","host","oldVnodeAttrs","newVnodeAttrs","undefined","createElm","oldParentVNode","newParentVNode","childIndex","parentElm","childNode","oldVNode","createTextNode","appendChild","putBackInOriginalLocation","recursive","oldSlotChildNodes","childNodes","parentReferenceNode","referenceNode","addVnodes","before","parentVNode","vnodes","startIdx","endIdx","containerElm","parentNode","removeVnodes","callNodeRefs","updateChildren","oldCh","newCh","oldStartIdx","newStartIdx","idxInOld","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","elmToMove","isSameVnode","patch","nextSibling","leftVNode","rightVNode","oldChildren","newChildren","defaultHolder","textContent","data","updateFallbackSlotVisibility","ilen","j","slotNameAttr","hidden","trim","relocateNodes","relocateSlotContent","hostContentNodes","relocateNodeData","isNodeLocatedInSlot","find","r","$nodeToRelocate$","$slotRefNode$","relocateNode","some","nodeToRelocate","vNode","renderVdom","renderFnResults","$vnode$","rootVnode","$attrsToReflect$","_a","propName","attribute","relocateData","orgLocationNode","parentNodeRef","insertBeforeNode","refNode","previousSibling","attachToAncestor","ancestorComponent","$onRenderResolve$","Promise","scheduleUpdate","isInitialLoad","$ancestorComponent$","dispatch","dispatchHooks","writeTask","endSchedule","instance","$lazyInstance$","promise","$queuedListeners$","methodName","event","safeCall","then","updateComponent","__awaiter","endUpdate","rc","endRender","callRender","childrenPromises","postUpdate","postUpdateComponent","all","render","consoleError","endPostUpdate","addHydratedFlag","$onReadyResolve$","appDidLoad","$onInstanceResolve$","nextTick","who","documentElement","namespace","method","arg","thenFn","getValue","$instanceValues$","setValue","newVal","oldVal","$members$","areBothNaN","Number","isNaN","didValueChange","$watchers$","watchMethods","watchMethodName","proxyComponent","Cstr","watchers","members","entries","prototype_1","prototype","memberFlags","defineProperty","this","configurable","enumerable","args","$onInstancePromise$","attrNameToPropName_1","Map","attributeChangedCallback","attrName","_oldValue","_this","jmp","hasOwnProperty","observedAttributes","_","m","initializeComponent","hmrVersionId","loadModule","endLoad","sent","isProxied","endNewInstance","fireConnectedCallback","endRegisterStyles","schedule","connectedCallback","endConnected","setContentReference","addHostEventListeners","$listeners$","contentRefElm","createComment","firstChild","disconnectedCallback","$rmListeners$","rmListener","bootstrapLazy","lazyBundles","options","endBootstrap","cmpTags","exclude","customElements","metaCharset","visibilityStyle","deferredConnectedCallbacks","appLoadFallback","isBootstrapping","$resourcesUrl$","URL","resourcesUrl","baseURI","href","lazyBundle","compactMeta","HostElement","_super","__extends","self","call","registerHost","clearTimeout","componentOnReady","$onReadyPromise$","HTMLElement","$lazyBundleId$","define","setTimeout","listeners","attachParentListeners","target","getHostListenerTarget","handler","hostListenerProxy","hostListenerOpts","hostRefs","registerInstance","lazyInstance","el","console","error","cmpModules","exportName","bundleId","module","import","concat","importedModule","window","document","raf","requestAnimationFrame","eventName","listener","addEventListener","removeEventListener","CustomEvent","promiseResolve","v","resolve","queueDomReads","queueDomWrites","queueTask","queue","write","flush","consume","performance","now"],"mappings":"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","sourcesContent":["export const NAMESPACE = \'taro-components\';\\nexport const BUILD = /* taro-components */ { allRenderFn: true, appendChildSlotFix: false, asyncLoading: true, asyncQueue: false, attachStyles: true, cloneNodeFix: false, cmpDidLoad: true, cmpDidRender: true, cmpDidUnload: false, cmpDidUpdate: true, cmpShouldUpdate: false, cmpWillLoad: true, cmpWillRender: false, cmpWillUpdate: true, connectedCallback: true, constructableCSS: true, cssAnnotations: true, cssVarShim: false, devTools: false, disconnectedCallback: true, dynamicImportShim: false, element: false, event: true, hasRenderFn: true, hostListener: true, hostListenerTarget: true, hostListenerTargetBody: false, hostListenerTargetDocument: true, hostListenerTargetParent: false, hostListenerTargetWindow: false, hotModuleReplacement: false, hydrateClientSide: false, hydrateServerSide: false, hydratedAttribute: false, hydratedClass: true, initializeNextTick: false, invisiblePrehydration: true, isDebug: false, isDev: false, isTesting: false, lazyLoad: true, lifecycle: true, lifecycleDOMEvents: false, member: true, method: true, mode: false, observeAttribute: true, profile: false, prop: true, propBoolean: true, propMutable: true, propNumber: true, propString: true, reflect: true, safari10: false, scoped: false, scopedSlotTextContentFix: false, scriptDataOpts: false, shadowDelegatesFocus: false, shadowDom: false, shadowDomShim: false, slot: true, slotChildNodesFix: false, slotRelocation: true, state: true, style: true, svg: false, taskQueue: true, transformTagName: false, updatable: true, vdomAttribute: true, vdomClass: true, vdomFunctional: true, vdomKey: true, vdomListener: true, vdomPropOrAttr: true, vdomRef: true, vdomRender: true, vdomStyle: true, vdomText: true, vdomXlink: true, watchCallback: true };\\nexport const Env = /* taro-components */ {};\\n","/**\\n * Virtual DOM patching algorithm based on Snabbdom by\\n * Simon Friis Vindum (@paldepind)\\n * Licensed under the MIT License\\n * https://github.com/snabbdom/snabbdom/blob/master/LICENSE\\n *\\n * Modified for Stencil\'s renderer and slot projection\\n */\\nlet scopeId;\\nlet contentRef;\\nlet hostTagName;\\nlet customError;\\nlet i = 0;\\nlet useNativeShadowDom = false;\\nlet checkSlotFallbackVisibility = false;\\nlet checkSlotRelocate = false;\\nlet isSvgMode = false;\\nlet renderingRef = null;\\nlet queueCongestion = 0;\\nlet queuePending = false;\\n/*\\n Stencil Client Platform v2.19.2 | MIT Licensed | https://stenciljs.com\\n */\\nimport { BUILD, NAMESPACE } from \'@stencil/core/internal/app-data\';\\nconst Build = {\\n    isDev: BUILD.isDev ? true : false,\\n    isBrowser: true,\\n    isServer: false,\\n    isTesting: BUILD.isTesting ? true : false,\\n};\\nconst Context = {};\\nconst getAssetPath = (path) => {\\n    const assetUrl = new URL(path, plt.$resourcesUrl$);\\n    return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\\n};\\nconst setAssetPath = (path) => (plt.$resourcesUrl$ = path);\\nconst createTime = (fnName, tagName = \'\') => {\\n    if (BUILD.profile && performance.mark) {\\n        const key = `st:${fnName}:${tagName}:${i++}`;\\n        // Start\\n        performance.mark(key);\\n        // End\\n        return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);\\n    }\\n    else {\\n        return () => {\\n            return;\\n        };\\n    }\\n};\\nconst uniqueTime = (key, measureText) => {\\n    if (BUILD.profile && performance.mark) {\\n        if (performance.getEntriesByName(key).length === 0) {\\n            performance.mark(key);\\n        }\\n        return () => {\\n            if (performance.getEntriesByName(measureText).length === 0) {\\n                performance.measure(measureText, key);\\n            }\\n        };\\n    }\\n    else {\\n        return () => {\\n            return;\\n        };\\n    }\\n};\\nconst inspect = (ref) => {\\n    const hostRef = getHostRef(ref);\\n    if (!hostRef) {\\n        return undefined;\\n    }\\n    const flags = hostRef.$flags$;\\n    const hostElement = hostRef.$hostElement$;\\n    return {\\n        renderCount: hostRef.$renderCount$,\\n        flags: {\\n            hasRendered: !!(flags & 2 /* HOST_FLAGS.hasRendered */),\\n            hasConnected: !!(flags & 1 /* HOST_FLAGS.hasConnected */),\\n            isWaitingForChildren: !!(flags & 4 /* HOST_FLAGS.isWaitingForChildren */),\\n            isConstructingInstance: !!(flags & 8 /* HOST_FLAGS.isConstructingInstance */),\\n            isQueuedForUpdate: !!(flags & 16 /* HOST_FLAGS.isQueuedForUpdate */),\\n            hasInitializedComponent: !!(flags & 32 /* HOST_FLAGS.hasInitializedComponent */),\\n            hasLoadedComponent: !!(flags & 64 /* HOST_FLAGS.hasLoadedComponent */),\\n            isWatchReady: !!(flags & 128 /* HOST_FLAGS.isWatchReady */),\\n            isListenReady: !!(flags & 256 /* HOST_FLAGS.isListenReady */),\\n            needsRerender: !!(flags & 512 /* HOST_FLAGS.needsRerender */),\\n        },\\n        instanceValues: hostRef.$instanceValues$,\\n        ancestorComponent: hostRef.$ancestorComponent$,\\n        hostElement,\\n        lazyInstance: hostRef.$lazyInstance$,\\n        vnode: hostRef.$vnode$,\\n        modeName: hostRef.$modeName$,\\n        onReadyPromise: hostRef.$onReadyPromise$,\\n        onReadyResolve: hostRef.$onReadyResolve$,\\n        onInstancePromise: hostRef.$onInstancePromise$,\\n        onInstanceResolve: hostRef.$onInstanceResolve$,\\n        onRenderResolve: hostRef.$onRenderResolve$,\\n        queuedListeners: hostRef.$queuedListeners$,\\n        rmListeners: hostRef.$rmListeners$,\\n        [\'s-id\']: hostElement[\'s-id\'],\\n        [\'s-cr\']: hostElement[\'s-cr\'],\\n        [\'s-lr\']: hostElement[\'s-lr\'],\\n        [\'s-p\']: hostElement[\'s-p\'],\\n        [\'s-rc\']: hostElement[\'s-rc\'],\\n        [\'s-sc\']: hostElement[\'s-sc\'],\\n    };\\n};\\nconst installDevTools = () => {\\n    if (BUILD.devTools) {\\n        const stencil = (win.stencil = win.stencil || {});\\n        const originalInspect = stencil.inspect;\\n        stencil.inspect = (ref) => {\\n            let result = inspect(ref);\\n            if (!result && typeof originalInspect === \'function\') {\\n                result = originalInspect(ref);\\n            }\\n            return result;\\n        };\\n    }\\n};\\nconst CONTENT_REF_ID = \'r\';\\nconst ORG_LOCATION_ID = \'o\';\\nconst SLOT_NODE_ID = \'s\';\\nconst TEXT_NODE_ID = \'t\';\\nconst HYDRATE_ID = \'s-id\';\\nconst HYDRATED_STYLE_ID = \'sty-id\';\\nconst HYDRATE_CHILD_ID = \'c-id\';\\nconst HYDRATED_CSS = \'{visibility:hidden}.hydrated{visibility:inherit}\';\\nconst XLINK_NS = \'http://www.w3.org/1999/xlink\';\\n/**\\n * Default style mode id\\n */\\n/**\\n * Reusable empty obj/array\\n * Don\'t add values to these!!\\n */\\nconst EMPTY_OBJ = {};\\n/**\\n * Namespaces\\n */\\nconst SVG_NS = \'http://www.w3.org/2000/svg\';\\nconst HTML_NS = \'http://www.w3.org/1999/xhtml\';\\nconst isDef = (v) => v != null;\\nconst isComplexType = (o) => {\\n    // https://jsperf.com/typeof-fn-object/5\\n    o = typeof o;\\n    return o === \'object\' || o === \'function\';\\n};\\n/**\\n * Production h() function based on Preact by\\n * Jason Miller (@developit)\\n * Licensed under the MIT License\\n * https://github.com/developit/preact/blob/master/LICENSE\\n *\\n * Modified for Stencil\'s compiler and vdom\\n */\\n// const stack: any[] = [];\\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\\nconst h = (nodeName, vnodeData, ...children) => {\\n    let child = null;\\n    let key = null;\\n    let slotName = null;\\n    let simple = false;\\n    let lastSimple = false;\\n    const vNodeChildren = [];\\n    const walk = (c) => {\\n        for (let i = 0; i < c.length; i++) {\\n            child = c[i];\\n            if (Array.isArray(child)) {\\n                walk(child);\\n            }\\n            else if (child != null && typeof child !== \'boolean\') {\\n                if ((simple = typeof nodeName !== \'function\' && !isComplexType(child))) {\\n                    child = String(child);\\n                }\\n                else if (BUILD.isDev && typeof nodeName !== \'function\' && child.$flags$ === undefined) {\\n                    consoleDevError(`vNode passed as children has unexpected type.\\nMake sure it\'s using the correct h() function.\\nEmpty objects can also be the cause, look for JSX comments that became objects.`);\\n                }\\n                if (simple && lastSimple) {\\n                    // If the previous child was simple (string), we merge both\\n                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;\\n                }\\n                else {\\n                    // Append a new vNode, if it\'s text, we create a text vNode\\n                    vNodeChildren.push(simple ? newVNode(null, child) : child);\\n                }\\n                lastSimple = simple;\\n            }\\n        }\\n    };\\n    walk(children);\\n    if (vnodeData) {\\n        if (BUILD.isDev && nodeName === \'input\') {\\n            validateInputProperties(vnodeData);\\n        }\\n        // normalize class / classname attributes\\n        if (BUILD.vdomKey && vnodeData.key) {\\n            key = vnodeData.key;\\n        }\\n        if (BUILD.slotRelocation && vnodeData.name) {\\n            slotName = vnodeData.name;\\n        }\\n        if (BUILD.vdomClass) {\\n            const classData = vnodeData.className || vnodeData.class;\\n            if (classData) {\\n                vnodeData.class =\\n                    typeof classData !== \'object\'\\n                        ? classData\\n                        : Object.keys(classData)\\n                            .filter((k) => classData[k])\\n                            .join(\' \');\\n            }\\n        }\\n    }\\n    if (BUILD.isDev && vNodeChildren.some(isHost)) {\\n        consoleDevError(`The <Host> must be the single root component. Make sure:\\n- You are NOT using hostData() and <Host> in the same component.\\n- <Host> is used once, and it\'s the single root component of the render() function.`);\\n    }\\n    if (BUILD.vdomFunctional && typeof nodeName === \'function\') {\\n        // nodeName is a functional component\\n        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);\\n    }\\n    const vnode = newVNode(nodeName, null);\\n    vnode.$attrs$ = vnodeData;\\n    if (vNodeChildren.length > 0) {\\n        vnode.$children$ = vNodeChildren;\\n    }\\n    if (BUILD.vdomKey) {\\n        vnode.$key$ = key;\\n    }\\n    if (BUILD.slotRelocation) {\\n        vnode.$name$ = slotName;\\n    }\\n    return vnode;\\n};\\nconst newVNode = (tag, text) => {\\n    const vnode = {\\n        $flags$: 0,\\n        $tag$: tag,\\n        $text$: text,\\n        $elm$: null,\\n        $children$: null,\\n    };\\n    if (BUILD.vdomAttribute) {\\n        vnode.$attrs$ = null;\\n    }\\n    if (BUILD.vdomKey) {\\n        vnode.$key$ = null;\\n    }\\n    if (BUILD.slotRelocation) {\\n        vnode.$name$ = null;\\n    }\\n    return vnode;\\n};\\nconst Host = {};\\nconst isHost = (node) => node && node.$tag$ === Host;\\nconst vdomFnUtils = {\\n    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),\\n    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),\\n};\\nconst convertToPublic = (node) => ({\\n    vattrs: node.$attrs$,\\n    vchildren: node.$children$,\\n    vkey: node.$key$,\\n    vname: node.$name$,\\n    vtag: node.$tag$,\\n    vtext: node.$text$,\\n});\\nconst convertToPrivate = (node) => {\\n    if (typeof node.vtag === \'function\') {\\n        const vnodeData = Object.assign({}, node.vattrs);\\n        if (node.vkey) {\\n            vnodeData.key = node.vkey;\\n        }\\n        if (node.vname) {\\n            vnodeData.name = node.vname;\\n        }\\n        return h(node.vtag, vnodeData, ...(node.vchildren || []));\\n    }\\n    const vnode = newVNode(node.vtag, node.vtext);\\n    vnode.$attrs$ = node.vattrs;\\n    vnode.$children$ = node.vchildren;\\n    vnode.$key$ = node.vkey;\\n    vnode.$name$ = node.vname;\\n    return vnode;\\n};\\n/**\\n * Validates the ordering of attributes on an input element\\n * @param inputElm the element to validate\\n */\\nconst validateInputProperties = (inputElm) => {\\n    const props = Object.keys(inputElm);\\n    const value = props.indexOf(\'value\');\\n    if (value === -1) {\\n        return;\\n    }\\n    const typeIndex = props.indexOf(\'type\');\\n    const minIndex = props.indexOf(\'min\');\\n    const maxIndex = props.indexOf(\'max\');\\n    const stepIndex = props.indexOf(\'step\');\\n    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {\\n        consoleDevWarn(`The \\"value\\" prop of <input> should be set after \\"min\\", \\"max\\", \\"type\\" and \\"step\\"`);\\n    }\\n};\\nconst initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {\\n    const endHydrate = createTime(\'hydrateClient\', tagName);\\n    const shadowRoot = hostElm.shadowRoot;\\n    const childRenderNodes = [];\\n    const slotNodes = [];\\n    const shadowRootNodes = BUILD.shadowDom && shadowRoot ? [] : null;\\n    const vnode = (hostRef.$vnode$ = newVNode(tagName, null));\\n    if (!plt.$orgLocNodes$) {\\n        initializeDocumentHydrate(doc.body, (plt.$orgLocNodes$ = new Map()));\\n    }\\n    hostElm[HYDRATE_ID] = hostId;\\n    hostElm.removeAttribute(HYDRATE_ID);\\n    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);\\n    childRenderNodes.map((c) => {\\n        const orgLocationId = c.$hostId$ + \'.\' + c.$nodeId$;\\n        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);\\n        const node = c.$elm$;\\n        if (orgLocationNode && supportsShadow && orgLocationNode[\'s-en\'] === \'\') {\\n            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);\\n        }\\n        if (!shadowRoot) {\\n            node[\'s-hn\'] = tagName;\\n            if (orgLocationNode) {\\n                node[\'s-ol\'] = orgLocationNode;\\n                node[\'s-ol\'][\'s-nr\'] = node;\\n            }\\n        }\\n        plt.$orgLocNodes$.delete(orgLocationId);\\n    });\\n    if (BUILD.shadowDom && shadowRoot) {\\n        shadowRootNodes.map((shadowRootNode) => {\\n            if (shadowRootNode) {\\n                shadowRoot.appendChild(shadowRootNode);\\n            }\\n        });\\n    }\\n    endHydrate();\\n};\\nconst clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {\\n    let childNodeType;\\n    let childIdSplt;\\n    let childVNode;\\n    let i;\\n    if (node.nodeType === 1 /* NODE_TYPE.ElementNode */) {\\n        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);\\n        if (childNodeType) {\\n            // got the node data from the element\'s attribute\\n            // `${hostId}.${nodeId}.${depth}.${index}`\\n            childIdSplt = childNodeType.split(\'.\');\\n            if (childIdSplt[0] === hostId || childIdSplt[0] === \'0\') {\\n                childVNode = {\\n                    $flags$: 0,\\n                    $hostId$: childIdSplt[0],\\n                    $nodeId$: childIdSplt[1],\\n                    $depth$: childIdSplt[2],\\n                    $index$: childIdSplt[3],\\n                    $tag$: node.tagName.toLowerCase(),\\n                    $elm$: node,\\n                    $attrs$: null,\\n                    $children$: null,\\n                    $key$: null,\\n                    $name$: null,\\n                    $text$: null,\\n                };\\n                childRenderNodes.push(childVNode);\\n                node.removeAttribute(HYDRATE_CHILD_ID);\\n                // this is a new child vnode\\n                // so ensure its parent vnode has the vchildren array\\n                if (!parentVNode.$children$) {\\n                    parentVNode.$children$ = [];\\n                }\\n                // add our child vnode to a specific index of the vnode\'s children\\n                parentVNode.$children$[childVNode.$index$] = childVNode;\\n                // this is now the new parent vnode for all the next child checks\\n                parentVNode = childVNode;\\n                if (shadowRootNodes && childVNode.$depth$ === \'0\') {\\n                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\\n                }\\n            }\\n        }\\n        // recursively drill down, end to start so we can remove nodes\\n        for (i = node.childNodes.length - 1; i >= 0; i--) {\\n            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);\\n        }\\n        if (node.shadowRoot) {\\n            // keep drilling down through the shadow root nodes\\n            for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {\\n                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);\\n            }\\n        }\\n    }\\n    else if (node.nodeType === 8 /* NODE_TYPE.CommentNode */) {\\n        // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`\\n        childIdSplt = node.nodeValue.split(\'.\');\\n        if (childIdSplt[1] === hostId || childIdSplt[1] === \'0\') {\\n            // comment node for either the host id or a 0 host id\\n            childNodeType = childIdSplt[0];\\n            childVNode = {\\n                $flags$: 0,\\n                $hostId$: childIdSplt[1],\\n                $nodeId$: childIdSplt[2],\\n                $depth$: childIdSplt[3],\\n                $index$: childIdSplt[4],\\n                $elm$: node,\\n                $attrs$: null,\\n                $children$: null,\\n                $key$: null,\\n                $name$: null,\\n                $tag$: null,\\n                $text$: null,\\n            };\\n            if (childNodeType === TEXT_NODE_ID) {\\n                childVNode.$elm$ = node.nextSibling;\\n                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* NODE_TYPE.TextNode */) {\\n                    childVNode.$text$ = childVNode.$elm$.textContent;\\n                    childRenderNodes.push(childVNode);\\n                    // remove the text comment since it\'s no longer needed\\n                    node.remove();\\n                    if (!parentVNode.$children$) {\\n                        parentVNode.$children$ = [];\\n                    }\\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\\n                    if (shadowRootNodes && childVNode.$depth$ === \'0\') {\\n                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\\n                    }\\n                }\\n            }\\n            else if (childVNode.$hostId$ === hostId) {\\n                // this comment node is specifcally for this host id\\n                if (childNodeType === SLOT_NODE_ID) {\\n                    // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;\\n                    childVNode.$tag$ = \'slot\';\\n                    if (childIdSplt[5]) {\\n                        node[\'s-sn\'] = childVNode.$name$ = childIdSplt[5];\\n                    }\\n                    else {\\n                        node[\'s-sn\'] = \'\';\\n                    }\\n                    node[\'s-sr\'] = true;\\n                    if (BUILD.shadowDom && shadowRootNodes) {\\n                        // browser support shadowRoot and this is a shadow dom component\\n                        // create an actual slot element\\n                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);\\n                        if (childVNode.$name$) {\\n                            // add the slot name attribute\\n                            childVNode.$elm$.setAttribute(\'name\', childVNode.$name$);\\n                        }\\n                        // insert the new slot element before the slot comment\\n                        node.parentNode.insertBefore(childVNode.$elm$, node);\\n                        // remove the slot comment since it\'s not needed for shadow\\n                        node.remove();\\n                        if (childVNode.$depth$ === \'0\') {\\n                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\\n                        }\\n                    }\\n                    slotNodes.push(childVNode);\\n                    if (!parentVNode.$children$) {\\n                        parentVNode.$children$ = [];\\n                    }\\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\\n                }\\n                else if (childNodeType === CONTENT_REF_ID) {\\n                    // `${CONTENT_REF_ID}.${hostId}`;\\n                    if (BUILD.shadowDom && shadowRootNodes) {\\n                        // remove the content ref comment since it\'s not needed for shadow\\n                        node.remove();\\n                    }\\n                    else if (BUILD.slotRelocation) {\\n                        hostElm[\'s-cr\'] = node;\\n                        node[\'s-cn\'] = true;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    else if (parentVNode && parentVNode.$tag$ === \'style\') {\\n        const vnode = newVNode(null, node.textContent);\\n        vnode.$elm$ = node;\\n        vnode.$index$ = \'0\';\\n        parentVNode.$children$ = [vnode];\\n    }\\n};\\nconst initializeDocumentHydrate = (node, orgLocNodes) => {\\n    if (node.nodeType === 1 /* NODE_TYPE.ElementNode */) {\\n        let i = 0;\\n        for (; i < node.childNodes.length; i++) {\\n            initializeDocumentHydrate(node.childNodes[i], orgLocNodes);\\n        }\\n        if (node.shadowRoot) {\\n            for (i = 0; i < node.shadowRoot.childNodes.length; i++) {\\n                initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);\\n            }\\n        }\\n    }\\n    else if (node.nodeType === 8 /* NODE_TYPE.CommentNode */) {\\n        const childIdSplt = node.nodeValue.split(\'.\');\\n        if (childIdSplt[0] === ORG_LOCATION_ID) {\\n            orgLocNodes.set(childIdSplt[1] + \'.\' + childIdSplt[2], node);\\n            node.nodeValue = \'\';\\n            // useful to know if the original location is\\n            // the root light-dom of a shadow dom component\\n            node[\'s-en\'] = childIdSplt[3];\\n        }\\n    }\\n};\\n// Private\\nconst computeMode = (elm) => modeResolutionChain.map((h) => h(elm)).find((m) => !!m);\\n// Public\\nconst setMode = (handler) => modeResolutionChain.push(handler);\\nconst getMode = (ref) => getHostRef(ref).$modeName$;\\n/**\\n * Parse a new property value for a given property type.\\n *\\n * While the prop value can reasonably be expected to be of `any` type as far as TypeScript\'s type checker is concerned,\\n * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:\\n *   1. `any`, the type given to `propValue` in the function signature\\n *   2. the type stored from `propType`.\\n *\\n * This function provides the capability to parse/coerce a property\'s value to potentially any other JavaScript type.\\n *\\n * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to\\n * a component. This `propValue` will preserve its type information (`typeof propValue === \'number\'`). Note that is\\n * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.\\n * ```tsx\\n * <my-cmp prop-val={0}></my-cmp>\\n * ```\\n *\\n * HTML prop values on the other hand, will always a string\\n *\\n * @param propValue the new value to coerce to some type\\n * @param propType the type of the prop, expressed as a binary number\\n * @returns the parsed/coerced value\\n */\\nconst parsePropertyValue = (propValue, propType) => {\\n    // ensure this value is of the correct prop type\\n    if (propValue != null && !isComplexType(propValue)) {\\n        if (BUILD.propBoolean && propType & 4 /* MEMBER_FLAGS.Boolean */) {\\n            // per the HTML spec, any string value means it is a boolean true value\\n            // but we\'ll cheat here and say that the string \\"false\\" is the boolean false\\n            return propValue === \'false\' ? false : propValue === \'\' || !!propValue;\\n        }\\n        if (BUILD.propNumber && propType & 2 /* MEMBER_FLAGS.Number */) {\\n            // force it to be a number\\n            return parseFloat(propValue);\\n        }\\n        if (BUILD.propString && propType & 1 /* MEMBER_FLAGS.String */) {\\n            // could have been passed as a number or boolean\\n            // but we still want it as a string\\n            return String(propValue);\\n        }\\n        // redundant return here for better minification\\n        return propValue;\\n    }\\n    // not sure exactly what type we want\\n    // so no need to change to a different type\\n    return propValue;\\n};\\nconst getElement = (ref) => (BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref);\\nconst createEvent = (ref, name, flags) => {\\n    const elm = getElement(ref);\\n    return {\\n        emit: (detail) => {\\n            if (BUILD.isDev && !elm.isConnected) {\\n                consoleDevWarn(`The \\"${name}\\" event was emitted, but the dispatcher node is no longer connected to the dom.`);\\n            }\\n            return emitEvent(elm, name, {\\n                bubbles: !!(flags & 4 /* EVENT_FLAGS.Bubbles */),\\n                composed: !!(flags & 2 /* EVENT_FLAGS.Composed */),\\n                cancelable: !!(flags & 1 /* EVENT_FLAGS.Cancellable */),\\n                detail,\\n            });\\n        },\\n    };\\n};\\n/**\\n * Helper function to create & dispatch a custom Event on a provided target\\n * @param elm the target of the Event\\n * @param name the name to give the custom Event\\n * @param opts options for configuring a custom Event\\n * @returns the custom Event\\n */\\nconst emitEvent = (elm, name, opts) => {\\n    const ev = plt.ce(name, opts);\\n    elm.dispatchEvent(ev);\\n    return ev;\\n};\\nconst rootAppliedStyles = /*@__PURE__*/ new WeakMap();\\nconst registerStyle = (scopeId, cssText, allowCS) => {\\n    let style = styles.get(scopeId);\\n    if (supportsConstructableStylesheets && allowCS) {\\n        style = (style || new CSSStyleSheet());\\n        if (typeof style === \'string\') {\\n            style = cssText;\\n        }\\n        else {\\n            style.replaceSync(cssText);\\n        }\\n    }\\n    else {\\n        style = cssText;\\n    }\\n    styles.set(scopeId, style);\\n};\\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {\\n    let scopeId = getScopeId(cmpMeta, mode);\\n    const style = styles.get(scopeId);\\n    if (!BUILD.attachStyles) {\\n        return scopeId;\\n    }\\n    // if an element is NOT connected then getRootNode() will return the wrong root node\\n    // so the fallback is to always use the document for the root node in those cases\\n    styleContainerNode = styleContainerNode.nodeType === 11 /* NODE_TYPE.DocumentFragment */ ? styleContainerNode : doc;\\n    if (style) {\\n        if (typeof style === \'string\') {\\n            styleContainerNode = styleContainerNode.head || styleContainerNode;\\n            let appliedStyles = rootAppliedStyles.get(styleContainerNode);\\n            let styleElm;\\n            if (!appliedStyles) {\\n                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));\\n            }\\n            if (!appliedStyles.has(scopeId)) {\\n                if (BUILD.hydrateClientSide &&\\n                    styleContainerNode.host &&\\n                    (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}=\\"${scopeId}\\"]`))) {\\n                    // This is only happening on native shadow-dom, do not needs CSS var shim\\n                    styleElm.innerHTML = style;\\n                }\\n                else {\\n                    if (BUILD.cssVarShim && plt.$cssShim$) {\\n                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* CMP_FLAGS.needsScopedEncapsulation */));\\n                        const newScopeId = styleElm[\'s-sc\'];\\n                        if (newScopeId) {\\n                            scopeId = newScopeId;\\n                            // we don\'t want to add this styleID to the appliedStyles Set\\n                            // since the cssVarShim might need to apply several different\\n                            // stylesheets for the same component\\n                            appliedStyles = null;\\n                        }\\n                    }\\n                    else {\\n                        styleElm = doc.createElement(\'style\');\\n                        styleElm.innerHTML = style;\\n                    }\\n                    if (BUILD.hydrateServerSide || BUILD.hotModuleReplacement) {\\n                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId);\\n                    }\\n                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector(\'link\'));\\n                }\\n                if (appliedStyles) {\\n                    appliedStyles.add(scopeId);\\n                }\\n            }\\n        }\\n        else if (BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {\\n            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\\n        }\\n    }\\n    return scopeId;\\n};\\nconst attachStyles = (hostRef) => {\\n    const cmpMeta = hostRef.$cmpMeta$;\\n    const elm = hostRef.$hostElement$;\\n    const flags = cmpMeta.$flags$;\\n    const endAttachStyles = createTime(\'attachStyles\', cmpMeta.$tagName$);\\n    const scopeId = addStyle(BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);\\n    if ((BUILD.shadowDom || BUILD.scoped) && BUILD.cssAnnotations && flags & 10 /* CMP_FLAGS.needsScopedEncapsulation */) {\\n        // only required when we\'re NOT using native shadow dom (slot)\\n        // or this browser doesn\'t support native shadow dom\\n        // and this host element was NOT created with SSR\\n        // let\'s pick out the inner content for slot projection\\n        // create a node to represent where the original\\n        // content was first placed, which is useful later on\\n        // DOM WRITE!!\\n        elm[\'s-sc\'] = scopeId;\\n        elm.classList.add(scopeId + \'-h\');\\n        if (BUILD.scoped && flags & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {\\n            elm.classList.add(scopeId + \'-s\');\\n        }\\n    }\\n    endAttachStyles();\\n};\\nconst getScopeId = (cmp, mode) => \'sc-\' + (BUILD.mode && mode && cmp.$flags$ & 32 /* CMP_FLAGS.hasMode */ ? cmp.$tagName$ + \'-\' + mode : cmp.$tagName$);\\nconst convertScopedToShadow = (css) => css.replace(/\\\\/\\\\*!@([^\\\\/]+)\\\\*\\\\/[^\\\\{]+\\\\{/g, \'$1{\');\\n/**\\n * Production setAccessor() function based on Preact by\\n * Jason Miller (@developit)\\n * Licensed under the MIT License\\n * https://github.com/developit/preact/blob/master/LICENSE\\n *\\n * Modified for Stencil\'s compiler and vdom\\n */\\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\\n    if (oldValue !== newValue) {\\n        let isProp = isMemberInElement(elm, memberName);\\n        let ln = memberName.toLowerCase();\\n        if (BUILD.vdomClass && memberName === \'class\') {\\n            const classList = elm.classList;\\n            const oldClasses = parseClassList(oldValue);\\n            const newClasses = parseClassList(newValue);\\n            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));\\n            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));\\n        }\\n        else if (BUILD.vdomStyle && memberName === \'style\') {\\n            // update style attribute, css properties and values\\n            if (BUILD.updatable) {\\n                for (const prop in oldValue) {\\n                    if (!newValue || newValue[prop] == null) {\\n                        if (!BUILD.hydrateServerSide && prop.includes(\'-\')) {\\n                            elm.style.removeProperty(prop);\\n                        }\\n                        else {\\n                            elm.style[prop] = \'\';\\n                        }\\n                    }\\n                }\\n            }\\n            for (const prop in newValue) {\\n                if (!oldValue || newValue[prop] !== oldValue[prop]) {\\n                    if (!BUILD.hydrateServerSide && prop.includes(\'-\')) {\\n                        elm.style.setProperty(prop, newValue[prop]);\\n                    }\\n                    else {\\n                        elm.style[prop] = newValue[prop];\\n                    }\\n                }\\n            }\\n        }\\n        else if (BUILD.vdomKey && memberName === \'key\')\\n            ;\\n        else if (BUILD.vdomRef && memberName === \'ref\') {\\n            // minifier will clean this up\\n            if (newValue) {\\n                newValue(elm);\\n            }\\n        }\\n        else if (BUILD.vdomListener &&\\n            (BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) &&\\n            memberName[0] === \'o\' &&\\n            memberName[1] === \'n\') {\\n            // Event Handlers\\n            // so if the member name starts with \\"on\\" and the 3rd characters is\\n            // a capital letter, and it\'s not already a member on the element,\\n            // then we\'re assuming it\'s an event listener\\n            if (memberName[2] === \'-\') {\\n                // on- prefixed events\\n                // allows to be explicit about the dom event to listen without any magic\\n                // under the hood:\\n                // <my-cmp on-click> // listens for \\"click\\"\\n                // <my-cmp on-Click> // listens for \\"Click\\"\\n                // <my-cmp on-ionChange> // listens for \\"ionChange\\"\\n                // <my-cmp on-EVENTS> // listens for \\"EVENTS\\"\\n                memberName = memberName.slice(3);\\n            }\\n            else if (isMemberInElement(win, ln)) {\\n                // standard event\\n                // the JSX attribute could have been \\"onMouseOver\\" and the\\n                // member name \\"onmouseover\\" is on the window\'s prototype\\n                // so let\'s add the listener \\"mouseover\\", which is all lowercased\\n                memberName = ln.slice(2);\\n            }\\n            else {\\n                // custom event\\n                // the JSX attribute could have been \\"onMyCustomEvent\\"\\n                // so let\'s trim off the \\"on\\" prefix and lowercase the first character\\n                // and add the listener \\"myCustomEvent\\"\\n                // except for the first character, we keep the event name case\\n                memberName = ln[2] + memberName.slice(3);\\n            }\\n            if (oldValue) {\\n                plt.rel(elm, memberName, oldValue, false);\\n            }\\n            if (newValue) {\\n                plt.ael(elm, memberName, newValue, false);\\n            }\\n        }\\n        else if (BUILD.vdomPropOrAttr) {\\n            // Set property if it exists and it\'s not a SVG\\n            const isComplex = isComplexType(newValue);\\n            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {\\n                try {\\n                    if (!elm.tagName.includes(\'-\')) {\\n                        const n = newValue == null ? \'\' : newValue;\\n                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued\\n                        if (memberName === \'list\') {\\n                            isProp = false;\\n                        }\\n                        else if (oldValue == null || elm[memberName] != n) {\\n                            elm[memberName] = n;\\n                        }\\n                    }\\n                    else {\\n                        elm[memberName] = newValue;\\n                    }\\n                }\\n                catch (e) { }\\n            }\\n            /**\\n             * Need to manually update attribute if:\\n             * - memberName is not an attribute\\n             * - if we are rendering the host element in order to reflect attribute\\n             * - if it\'s a SVG, since properties might not work in <svg>\\n             * - if the newValue is null/undefined or \'false\'.\\n             */\\n            let xlink = false;\\n            if (BUILD.vdomXlink) {\\n                if (ln !== (ln = ln.replace(/^xlink\\\\:?/, \'\'))) {\\n                    memberName = ln;\\n                    xlink = true;\\n                }\\n            }\\n            if (newValue == null || newValue === false) {\\n                if (newValue !== false || elm.getAttribute(memberName) === \'\') {\\n                    if (BUILD.vdomXlink && xlink) {\\n                        elm.removeAttributeNS(XLINK_NS, memberName);\\n                    }\\n                    else {\\n                        elm.removeAttribute(memberName);\\n                    }\\n                }\\n            }\\n            else if ((!isProp || flags & 4 /* VNODE_FLAGS.isHost */ || isSvg) && !isComplex) {\\n                newValue = newValue === true ? \'\' : newValue;\\n                if (BUILD.vdomXlink && xlink) {\\n                    elm.setAttributeNS(XLINK_NS, memberName, newValue);\\n                }\\n                else {\\n                    elm.setAttribute(memberName, newValue);\\n                }\\n            }\\n        }\\n    }\\n};\\nconst parseClassListRegex = /\\\\s/;\\nconst parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));\\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\\n    // if the element passed in is a shadow root, which is a document fragment\\n    // then we want to be adding attrs/props to the shadow root\'s \\"host\\" element\\n    // if it\'s not a shadow root, then we add attrs/props to the same element\\n    const elm = newVnode.$elm$.nodeType === 11 /* NODE_TYPE.DocumentFragment */ && newVnode.$elm$.host\\n        ? newVnode.$elm$.host\\n        : newVnode.$elm$;\\n    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;\\n    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\\n    if (BUILD.updatable) {\\n        // remove attributes no longer present on the vnode by setting them to undefined\\n        for (memberName in oldVnodeAttrs) {\\n            if (!(memberName in newVnodeAttrs)) {\\n                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\\n            }\\n        }\\n    }\\n    // add new & update changed attributes\\n    for (memberName in newVnodeAttrs) {\\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\\n    }\\n};\\n/**\\n * Create a DOM Node corresponding to one of the children of a given VNode.\\n *\\n * @param oldParentVNode the parent VNode from the previous render\\n * @param newParentVNode the parent VNode from the current render\\n * @param childIndex the index of the VNode, in the _new_ parent node\'s\\n * children, for which we will create a new DOM node\\n * @param parentElm the parent DOM node which our new node will be a child of\\n * @returns the newly created node\\n */\\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\\n    // tslint:disable-next-line: prefer-const\\n    const newVNode = newParentVNode.$children$[childIndex];\\n    let i = 0;\\n    let elm;\\n    let childNode;\\n    let oldVNode;\\n    if (BUILD.slotRelocation && !useNativeShadowDom) {\\n        // remember for later we need to check to relocate nodes\\n        checkSlotRelocate = true;\\n        if (newVNode.$tag$ === \'slot\') {\\n            if (scopeId) {\\n                // scoped css needs to add its scoped id to the parent element\\n                parentElm.classList.add(scopeId + \'-s\');\\n            }\\n            newVNode.$flags$ |= newVNode.$children$\\n                ? // slot element has fallback content\\n                    2 /* VNODE_FLAGS.isSlotFallback */\\n                : // slot element does not have fallback content\\n                    1 /* VNODE_FLAGS.isSlotReference */;\\n        }\\n    }\\n    if (BUILD.isDev && newVNode.$elm$) {\\n        consoleDevError(`The JSX ${newVNode.$text$ !== null ? `\\"${newVNode.$text$}\\" text` : `\\"${newVNode.$tag$}\\" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);\\n    }\\n    if (BUILD.vdomText && newVNode.$text$ !== null) {\\n        // create text node\\n        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\\n    }\\n    else if (BUILD.slotRelocation && newVNode.$flags$ & 1 /* VNODE_FLAGS.isSlotReference */) {\\n        // create a slot reference node\\n        elm = newVNode.$elm$ =\\n            BUILD.isDebug || BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode) : doc.createTextNode(\'\');\\n    }\\n    else {\\n        if (BUILD.svg && !isSvgMode) {\\n            isSvgMode = newVNode.$tag$ === \'svg\';\\n        }\\n        // create element\\n        elm = newVNode.$elm$ = (BUILD.svg\\n            ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, BUILD.slotRelocation && newVNode.$flags$ & 2 /* VNODE_FLAGS.isSlotFallback */\\n                ? \'slot-fb\'\\n                : newVNode.$tag$)\\n            : doc.createElement(BUILD.slotRelocation && newVNode.$flags$ & 2 /* VNODE_FLAGS.isSlotFallback */\\n                ? \'slot-fb\'\\n                : newVNode.$tag$));\\n        if (BUILD.svg && isSvgMode && newVNode.$tag$ === \'foreignObject\') {\\n            isSvgMode = false;\\n        }\\n        // add css classes, attrs, props, listeners, etc.\\n        if (BUILD.vdomAttribute) {\\n            updateElement(null, newVNode, isSvgMode);\\n        }\\n        if ((BUILD.shadowDom || BUILD.scoped) && isDef(scopeId) && elm[\'s-si\'] !== scopeId) {\\n            // if there is a scopeId and this is the initial render\\n            // then let\'s add the scopeId as a css class\\n            elm.classList.add((elm[\'s-si\'] = scopeId));\\n        }\\n        if (newVNode.$children$) {\\n            for (i = 0; i < newVNode.$children$.length; ++i) {\\n                // create the node\\n                childNode = createElm(oldParentVNode, newVNode, i, elm);\\n                // return node could have been null\\n                if (childNode) {\\n                    // append our new node\\n                    elm.appendChild(childNode);\\n                }\\n            }\\n        }\\n        if (BUILD.svg) {\\n            if (newVNode.$tag$ === \'svg\') {\\n                // Only reset the SVG context when we\'re exiting <svg> element\\n                isSvgMode = false;\\n            }\\n            else if (elm.tagName === \'foreignObject\') {\\n                // Reenter SVG context when we\'re exiting <foreignObject> element\\n                isSvgMode = true;\\n            }\\n        }\\n    }\\n    if (BUILD.slotRelocation) {\\n        elm[\'s-hn\'] = hostTagName;\\n        if (newVNode.$flags$ & (2 /* VNODE_FLAGS.isSlotFallback */ | 1 /* VNODE_FLAGS.isSlotReference */)) {\\n            // remember the content reference comment\\n            elm[\'s-sr\'] = true;\\n            // remember the content reference comment\\n            elm[\'s-cr\'] = contentRef;\\n            // remember the slot name, or empty string for default slot\\n            elm[\'s-sn\'] = newVNode.$name$ || \'\';\\n            // check if we\'ve got an old vnode for this slot\\n            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\\n            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {\\n                // we\'ve got an old slot vnode and the wrapper is being replaced\\n                // so let\'s move the old slot content back to it\'s original location\\n                putBackInOriginalLocation(oldParentVNode.$elm$, false);\\n            }\\n        }\\n    }\\n    return elm;\\n};\\nconst putBackInOriginalLocation = (parentElm, recursive) => {\\n    plt.$flags$ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;\\n    const oldSlotChildNodes = parentElm.childNodes;\\n    for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {\\n        const childNode = oldSlotChildNodes[i];\\n        if (childNode[\'s-hn\'] !== hostTagName && childNode[\'s-ol\']) {\\n            // // this child node in the old element is from another component\\n            // // remove this node from the old slot\'s parent\\n            // childNode.remove();\\n            // and relocate it back to it\'s original location\\n            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));\\n            // remove the old original location comment entirely\\n            // later on the patch function will know what to do\\n            // and move this to the correct spot in need be\\n            childNode[\'s-ol\'].remove();\\n            childNode[\'s-ol\'] = undefined;\\n            checkSlotRelocate = true;\\n        }\\n        if (recursive) {\\n            putBackInOriginalLocation(childNode, recursive);\\n        }\\n    }\\n    plt.$flags$ &= ~1 /* PLATFORM_FLAGS.isTmpDisconnected */;\\n};\\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\\n    let containerElm = ((BUILD.slotRelocation && parentElm[\'s-cr\'] && parentElm[\'s-cr\'].parentNode) || parentElm);\\n    let childNode;\\n    if (BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {\\n        containerElm = containerElm.shadowRoot;\\n    }\\n    for (; startIdx <= endIdx; ++startIdx) {\\n        if (vnodes[startIdx]) {\\n            childNode = createElm(null, parentVNode, startIdx, parentElm);\\n            if (childNode) {\\n                vnodes[startIdx].$elm$ = childNode;\\n                containerElm.insertBefore(childNode, BUILD.slotRelocation ? referenceNode(before) : before);\\n            }\\n        }\\n    }\\n};\\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {\\n    for (; startIdx <= endIdx; ++startIdx) {\\n        if ((vnode = vnodes[startIdx])) {\\n            elm = vnode.$elm$;\\n            callNodeRefs(vnode);\\n            if (BUILD.slotRelocation) {\\n                // we\'re removing this element\\n                // so it\'s possible we need to show slot fallback content now\\n                checkSlotFallbackVisibility = true;\\n                if (elm[\'s-ol\']) {\\n                    // remove the original location comment\\n                    elm[\'s-ol\'].remove();\\n                }\\n                else {\\n                    // it\'s possible that child nodes of the node\\n                    // that\'s being removed are slot nodes\\n                    putBackInOriginalLocation(elm, true);\\n                }\\n            }\\n            // remove the vnode\'s element from the dom\\n            elm.remove();\\n        }\\n    }\\n};\\n/**\\n * Reconcile the children of a new VNode with the children of an old VNode by\\n * traversing the two collections of children, identifying nodes that are\\n * conserved or changed, calling out to `patch` to make any necessary\\n * updates to the DOM, and rearranging DOM nodes as needed.\\n *\\n * The algorithm for reconciling children works by analyzing two \'windows\' onto\\n * the two arrays of children (`oldCh` and `newCh`). We keep track of the\\n * \'windows\' by storing start and end indices and references to the\\n * corresponding array entries. Initially the two \'windows\' are basically equal\\n * to the entire array, but we progressively narrow the windows until there are\\n * no children left to update by doing the following:\\n *\\n * 1. Skip any `null` entries at the beginning or end of the two arrays, so\\n *    that if we have an initial array like the following we\'ll end up dealing\\n *    only with a window bounded by the highlighted elements:\\n *\\n *    [null, null, VNode1 , ... , VNode2, null, null]\\n *                 ^^^^^^         ^^^^^^\\n *\\n * 2. Check to see if the elements at the head and tail positions are equal\\n *    across the windows. This will basically detect elements which haven\'t\\n *    been added, removed, or changed position, i.e. if you had the following\\n *    VNode elements (represented as HTML):\\n *\\n *    oldVNode: `<div><p><span>HEY</span></p></div>`\\n *    newVNode: `<div><p><span>THERE</span></p></div>`\\n *\\n *    Then when comparing the children of the `<div>` tag we check the equality\\n *    of the VNodes corresponding to the `<p>` tags and, since they are the\\n *    same tag in the same position, we\'d be able to avoid completely\\n *    re-rendering the subtree under them with a new DOM element and would just\\n *    call out to `patch` to handle reconciling their children and so on.\\n *\\n * 3. Check, for both windows, to see if the element at the beginning of the\\n *    window corresponds to the element at the end of the other window. This is\\n *    a heuristic which will let us identify _some_ situations in which\\n *    elements have changed position, for instance it _should_ detect that the\\n *    children nodes themselves have not changed but merely moved in the\\n *    following example:\\n *\\n *    oldVNode: `<div><element-one /><element-two /></div>`\\n *    newVNode: `<div><element-two /><element-one /></div>`\\n *\\n *    If we find cases like this then we also need to move the concrete DOM\\n *    elements corresponding to the moved children to write the re-order to the\\n *    DOM.\\n *\\n * 4. Finally, if VNodes have the `key` attribute set on them we check for any\\n *    nodes in the old children which have the same key as the first element in\\n *    our window on the new children. If we find such a node we handle calling\\n *    out to `patch`, moving relevant DOM nodes, and so on, in accordance with\\n *    what we find.\\n *\\n * Finally, once we\'ve narrowed our \'windows\' to the point that either of them\\n * collapse (i.e. they have length 0) we then handle any remaining VNode\\n * insertion or deletion that needs to happen to get a DOM state that correctly\\n * reflects the new child VNodes. If, for instance, after our window on the old\\n * children has collapsed we still have more nodes on the new children that\\n * we haven\'t dealt with yet then we need to add them, or if the new children\\n * collapse but we still have unhandled _old_ children then we need to make\\n * sure the corresponding DOM nodes are removed.\\n *\\n * @param parentElm the node into which the parent VNode is rendered\\n * @param oldCh the old children of the parent node\\n * @param newVNode the new VNode which will replace the parent\\n * @param newCh the new children of the parent node\\n */\\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\\n    let oldStartIdx = 0;\\n    let newStartIdx = 0;\\n    let idxInOld = 0;\\n    let i = 0;\\n    let oldEndIdx = oldCh.length - 1;\\n    let oldStartVnode = oldCh[0];\\n    let oldEndVnode = oldCh[oldEndIdx];\\n    let newEndIdx = newCh.length - 1;\\n    let newStartVnode = newCh[0];\\n    let newEndVnode = newCh[newEndIdx];\\n    let node;\\n    let elmToMove;\\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\\n        if (oldStartVnode == null) {\\n            // VNode might have been moved left\\n            oldStartVnode = oldCh[++oldStartIdx];\\n        }\\n        else if (oldEndVnode == null) {\\n            oldEndVnode = oldCh[--oldEndIdx];\\n        }\\n        else if (newStartVnode == null) {\\n            newStartVnode = newCh[++newStartIdx];\\n        }\\n        else if (newEndVnode == null) {\\n            newEndVnode = newCh[--newEndIdx];\\n        }\\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\\n            // if the start nodes are the same then we should patch the new VNode\\n            // onto the old one, and increment our `newStartIdx` and `oldStartIdx`\\n            // indices to reflect that. We don\'t need to move any DOM Nodes around\\n            // since things are matched up in order.\\n            patch(oldStartVnode, newStartVnode);\\n            oldStartVnode = oldCh[++oldStartIdx];\\n            newStartVnode = newCh[++newStartIdx];\\n        }\\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\\n            // likewise, if the end nodes are the same we patch new onto old and\\n            // decrement our end indices, and also likewise in this case we don\'t\\n            // need to move any DOM Nodes.\\n            patch(oldEndVnode, newEndVnode);\\n            oldEndVnode = oldCh[--oldEndIdx];\\n            newEndVnode = newCh[--newEndIdx];\\n        }\\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\\n            // case: \\"Vnode moved right\\"\\n            //\\n            // We\'ve found that the last node in our window on the new children is\\n            // the same VNode as the _first_ node in our window on the old children\\n            // we\'re dealing with now. Visually, this is the layout of these two\\n            // nodes:\\n            //\\n            // newCh: [..., newStartVnode , ... , newEndVnode , ...]\\n            //                                    ^^^^^^^^^^^\\n            // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]\\n            //              ^^^^^^^^^^^^^\\n            //\\n            // In this situation we need to patch `newEndVnode` onto `oldStartVnode`\\n            // and move the DOM element for `oldStartVnode`.\\n            if (BUILD.slotRelocation && (oldStartVnode.$tag$ === \'slot\' || newEndVnode.$tag$ === \'slot\')) {\\n                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\\n            }\\n            patch(oldStartVnode, newEndVnode);\\n            // We need to move the element for `oldStartVnode` into a position which\\n            // will be appropriate for `newEndVnode`. For this we can use\\n            // `.insertBefore` and `oldEndVnode.$elm$.nextSibling`. If there is a\\n            // sibling for `oldEndVnode.$elm$` then we want to move the DOM node for\\n            // `oldStartVnode` between `oldEndVnode` and it\'s sibling, like so:\\n            //\\n            // <old-start-node />\\n            // <some-intervening-node />\\n            // <old-end-node />\\n            // \x3c!-- ->              <-- `oldStartVnode.$elm$` should be inserted here\\n            // <next-sibling />\\n            //\\n            // If instead `oldEndVnode.$elm$` has no sibling then we just want to put\\n            // the node for `oldStartVnode` at the end of the children of\\n            // `parentElm`. Luckily, `Node.nextSibling` will return `null` if there\\n            // aren\'t any siblings, and passing `null` to `Node.insertBefore` will\\n            // append it to the children of the parent element.\\n            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\\n            oldStartVnode = oldCh[++oldStartIdx];\\n            newEndVnode = newCh[--newEndIdx];\\n        }\\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\\n            // case: \\"Vnode moved left\\"\\n            //\\n            // We\'ve found that the first node in our window on the new children is\\n            // the same VNode as the _last_ node in our window on the old children.\\n            // Visually, this is the layout of these two nodes:\\n            //\\n            // newCh: [..., newStartVnode , ... , newEndVnode , ...]\\n            //              ^^^^^^^^^^^^^\\n            // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]\\n            //                                    ^^^^^^^^^^^\\n            //\\n            // In this situation we need to patch `newStartVnode` onto `oldEndVnode`\\n            // (which will handle updating any changed attributes, reconciling their\\n            // children etc) but we also need to move the DOM node to which\\n            // `oldEndVnode` corresponds.\\n            if (BUILD.slotRelocation && (oldStartVnode.$tag$ === \'slot\' || newEndVnode.$tag$ === \'slot\')) {\\n                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\\n            }\\n            patch(oldEndVnode, newStartVnode);\\n            // We\'ve already checked above if `oldStartVnode` and `newStartVnode` are\\n            // the same node, so since we\'re here we know that they are not. Thus we\\n            // can move the element for `oldEndVnode` _before_ the element for\\n            // `oldStartVnode`, leaving `oldStartVnode` to be reconciled in the\\n            // future.\\n            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\\n            oldEndVnode = oldCh[--oldEndIdx];\\n            newStartVnode = newCh[++newStartIdx];\\n        }\\n        else {\\n            // Here we do some checks to match up old and new nodes based on the\\n            // `$key$` attribute, which is set by putting a `key=\\"my-key\\"` attribute\\n            // in the JSX for a DOM element in the implementation of a Stencil\\n            // component.\\n            //\\n            // First we check to see if there are any nodes in the array of old\\n            // children which have the same key as the first node in the new\\n            // children.\\n            idxInOld = -1;\\n            if (BUILD.vdomKey) {\\n                for (i = oldStartIdx; i <= oldEndIdx; ++i) {\\n                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {\\n                        idxInOld = i;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (BUILD.vdomKey && idxInOld >= 0) {\\n                // We found a node in the old children which matches up with the first\\n                // node in the new children! So let\'s deal with that\\n                elmToMove = oldCh[idxInOld];\\n                if (elmToMove.$tag$ !== newStartVnode.$tag$) {\\n                    // the tag doesn\'t match so we\'ll need a new DOM element\\n                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);\\n                }\\n                else {\\n                    patch(elmToMove, newStartVnode);\\n                    // invalidate the matching old node so that we won\'t try to update it\\n                    // again later on\\n                    oldCh[idxInOld] = undefined;\\n                    node = elmToMove.$elm$;\\n                }\\n                newStartVnode = newCh[++newStartIdx];\\n            }\\n            else {\\n                // We either didn\'t find an element in the old children that matches\\n                // the key of the first new child OR the build is not using `key`\\n                // attributes at all. In either case we need to create a new element\\n                // for the new node.\\n                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);\\n                newStartVnode = newCh[++newStartIdx];\\n            }\\n            if (node) {\\n                // if we created a new node then handle inserting it to the DOM\\n                if (BUILD.slotRelocation) {\\n                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));\\n                }\\n                else {\\n                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\\n                }\\n            }\\n        }\\n    }\\n    if (oldStartIdx > oldEndIdx) {\\n        // we have some more new nodes to add which don\'t match up with old nodes\\n        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\\n    }\\n    else if (BUILD.updatable && newStartIdx > newEndIdx) {\\n        // there are nodes in the `oldCh` array which no longer correspond to nodes\\n        // in the new array, so lets remove them (which entails cleaning up the\\n        // relevant DOM nodes)\\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\\n    }\\n};\\n/**\\n * Compare two VNodes to determine if they are the same\\n *\\n * **NB**: This function is an equality _heuristic_ based on the available\\n * information set on the two VNodes and can be misleading under certain\\n * circumstances. In particular, if the two nodes do not have `key` attrs\\n * (available under `$key$` on VNodes) then the function falls back on merely\\n * checking that they have the same tag.\\n *\\n * So, in other words, if `key` attrs are not set on VNodes which may be\\n * changing order within a `children` array or something along those lines then\\n * we could obtain a false positive and then have to do needless re-rendering.\\n *\\n * @param leftVNode the first VNode to check\\n * @param rightVNode the second VNode to check\\n * @returns whether they\'re equal or not\\n */\\nconst isSameVnode = (leftVNode, rightVNode) => {\\n    // compare if two vnode to see if they\'re \\"technically\\" the same\\n    // need to have the same element tag, and same key to be the same\\n    if (leftVNode.$tag$ === rightVNode.$tag$) {\\n        if (BUILD.slotRelocation && leftVNode.$tag$ === \'slot\') {\\n            return leftVNode.$name$ === rightVNode.$name$;\\n        }\\n        // this will be set if components in the build have `key` attrs set on them\\n        if (BUILD.vdomKey) {\\n            return leftVNode.$key$ === rightVNode.$key$;\\n        }\\n        return true;\\n    }\\n    return false;\\n};\\nconst referenceNode = (node) => {\\n    // this node was relocated to a new location in the dom\\n    // because of some other component\'s slot\\n    // but we still have an html comment in place of where\\n    // it\'s original location was according to it\'s original vdom\\n    return (node && node[\'s-ol\']) || node;\\n};\\nconst parentReferenceNode = (node) => (node[\'s-ol\'] ? node[\'s-ol\'] : node).parentNode;\\n/**\\n * Handle reconciling an outdated VNode with a new one which corresponds to\\n * it. This function handles flushing updates to the DOM and reconciling the\\n * children of the two nodes (if any).\\n *\\n * @param oldVNode an old VNode whose DOM element and children we want to update\\n * @param newVNode a new VNode representing an updated version of the old one\\n */\\nconst patch = (oldVNode, newVNode) => {\\n    const elm = (newVNode.$elm$ = oldVNode.$elm$);\\n    const oldChildren = oldVNode.$children$;\\n    const newChildren = newVNode.$children$;\\n    const tag = newVNode.$tag$;\\n    const text = newVNode.$text$;\\n    let defaultHolder;\\n    if (!BUILD.vdomText || text === null) {\\n        if (BUILD.svg) {\\n            // test if we\'re rendering an svg element, or still rendering nodes inside of one\\n            // only add this to the when the compiler sees we\'re using an svg somewhere\\n            isSvgMode = tag === \'svg\' ? true : tag === \'foreignObject\' ? false : isSvgMode;\\n        }\\n        if (BUILD.vdomAttribute || BUILD.reflect) {\\n            if (BUILD.slot && tag === \'slot\')\\n                ;\\n            else {\\n                // either this is the first render of an element OR it\'s an update\\n                // AND we already know it\'s possible it could have changed\\n                // this updates the element\'s css classes, attrs, props, listeners, etc.\\n                updateElement(oldVNode, newVNode, isSvgMode);\\n            }\\n        }\\n        if (BUILD.updatable && oldChildren !== null && newChildren !== null) {\\n            // looks like there\'s child vnodes for both the old and new vnodes\\n            // so we need to call `updateChildren` to reconcile them\\n            updateChildren(elm, oldChildren, newVNode, newChildren);\\n        }\\n        else if (newChildren !== null) {\\n            // no old child vnodes, but there are new child vnodes to add\\n            if (BUILD.updatable && BUILD.vdomText && oldVNode.$text$ !== null) {\\n                // the old vnode was text, so be sure to clear it out\\n                elm.textContent = \'\';\\n            }\\n            // add the new vnode children\\n            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\\n        }\\n        else if (BUILD.updatable && oldChildren !== null) {\\n            // no new child vnodes, but there are old child vnodes to remove\\n            removeVnodes(oldChildren, 0, oldChildren.length - 1);\\n        }\\n        if (BUILD.svg && isSvgMode && tag === \'svg\') {\\n            isSvgMode = false;\\n        }\\n    }\\n    else if (BUILD.vdomText && BUILD.slotRelocation && (defaultHolder = elm[\'s-cr\'])) {\\n        // this element has slotted content\\n        defaultHolder.parentNode.textContent = text;\\n    }\\n    else if (BUILD.vdomText && oldVNode.$text$ !== text) {\\n        // update the text content for the text only vnode\\n        // and also only if the text is different than before\\n        elm.data = text;\\n    }\\n};\\nconst updateFallbackSlotVisibility = (elm) => {\\n    // tslint:disable-next-line: prefer-const\\n    const childNodes = elm.childNodes;\\n    let childNode;\\n    let i;\\n    let ilen;\\n    let j;\\n    let slotNameAttr;\\n    let nodeType;\\n    for (i = 0, ilen = childNodes.length; i < ilen; i++) {\\n        childNode = childNodes[i];\\n        if (childNode.nodeType === 1 /* NODE_TYPE.ElementNode */) {\\n            if (childNode[\'s-sr\']) {\\n                // this is a slot fallback node\\n                // get the slot name for this slot reference node\\n                slotNameAttr = childNode[\'s-sn\'];\\n                // by default always show a fallback slot node\\n                // then hide it if there are other slots in the light dom\\n                childNode.hidden = false;\\n                for (j = 0; j < ilen; j++) {\\n                    nodeType = childNodes[j].nodeType;\\n                    if (childNodes[j][\'s-hn\'] !== childNode[\'s-hn\'] || slotNameAttr !== \'\') {\\n                        // this sibling node is from a different component OR is a named fallback slot node\\n                        if (nodeType === 1 /* NODE_TYPE.ElementNode */ && slotNameAttr === childNodes[j].getAttribute(\'slot\')) {\\n                            childNode.hidden = true;\\n                            break;\\n                        }\\n                    }\\n                    else {\\n                        // this is a default fallback slot node\\n                        // any element or text node (with content)\\n                        // should hide the default fallback slot node\\n                        if (nodeType === 1 /* NODE_TYPE.ElementNode */ ||\\n                            (nodeType === 3 /* NODE_TYPE.TextNode */ && childNodes[j].textContent.trim() !== \'\')) {\\n                            childNode.hidden = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            // keep drilling down\\n            updateFallbackSlotVisibility(childNode);\\n        }\\n    }\\n};\\nconst relocateNodes = [];\\nconst relocateSlotContent = (elm) => {\\n    // tslint:disable-next-line: prefer-const\\n    let childNode;\\n    let node;\\n    let hostContentNodes;\\n    let slotNameAttr;\\n    let relocateNodeData;\\n    let j;\\n    let i = 0;\\n    const childNodes = elm.childNodes;\\n    const ilen = childNodes.length;\\n    for (; i < ilen; i++) {\\n        childNode = childNodes[i];\\n        if (childNode[\'s-sr\'] && (node = childNode[\'s-cr\']) && node.parentNode) {\\n            // first got the content reference comment node\\n            // then we got it\'s parent, which is where all the host content is in now\\n            hostContentNodes = node.parentNode.childNodes;\\n            slotNameAttr = childNode[\'s-sn\'];\\n            for (j = hostContentNodes.length - 1; j >= 0; j--) {\\n                node = hostContentNodes[j];\\n                if (!node[\'s-cn\'] && !node[\'s-nr\'] && node[\'s-hn\'] !== childNode[\'s-hn\']) {\\n                    // let\'s do some relocating to its new home\\n                    // but never relocate a content reference node\\n                    // that is suppose to always represent the original content location\\n                    if (isNodeLocatedInSlot(node, slotNameAttr)) {\\n                        // it\'s possible we\'ve already decided to relocate this node\\n                        relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\\n                        // made some changes to slots\\n                        // let\'s make sure we also double check\\n                        // fallbacks are correctly hidden or shown\\n                        checkSlotFallbackVisibility = true;\\n                        node[\'s-sn\'] = node[\'s-sn\'] || slotNameAttr;\\n                        if (relocateNodeData) {\\n                            // previously we never found a slot home for this node\\n                            // but turns out we did, so let\'s remember it now\\n                            relocateNodeData.$slotRefNode$ = childNode;\\n                        }\\n                        else {\\n                            // add to our list of nodes to relocate\\n                            relocateNodes.push({\\n                                $slotRefNode$: childNode,\\n                                $nodeToRelocate$: node,\\n                            });\\n                        }\\n                        if (node[\'s-sr\']) {\\n                            relocateNodes.map((relocateNode) => {\\n                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node[\'s-sn\'])) {\\n                                    relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\\n                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {\\n                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\\n                                    }\\n                                }\\n                            });\\n                        }\\n                    }\\n                    else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {\\n                        // so far this element does not have a slot home, not setting slotRefNode on purpose\\n                        // if we never find a home for this element then we\'ll need to hide it\\n                        relocateNodes.push({\\n                            $nodeToRelocate$: node,\\n                        });\\n                    }\\n                }\\n            }\\n        }\\n        if (childNode.nodeType === 1 /* NODE_TYPE.ElementNode */) {\\n            relocateSlotContent(childNode);\\n        }\\n    }\\n};\\nconst isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {\\n    if (nodeToRelocate.nodeType === 1 /* NODE_TYPE.ElementNode */) {\\n        if (nodeToRelocate.getAttribute(\'slot\') === null && slotNameAttr === \'\') {\\n            return true;\\n        }\\n        if (nodeToRelocate.getAttribute(\'slot\') === slotNameAttr) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    if (nodeToRelocate[\'s-sn\'] === slotNameAttr) {\\n        return true;\\n    }\\n    return slotNameAttr === \'\';\\n};\\nconst callNodeRefs = (vNode) => {\\n    if (BUILD.vdomRef) {\\n        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\\n        vNode.$children$ && vNode.$children$.map(callNodeRefs);\\n    }\\n};\\nconst renderVdom = (hostRef, renderFnResults) => {\\n    const hostElm = hostRef.$hostElement$;\\n    const cmpMeta = hostRef.$cmpMeta$;\\n    const oldVNode = hostRef.$vnode$ || newVNode(null, null);\\n    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\\n    hostTagName = hostElm.tagName;\\n    // <Host> runtime check\\n    if (BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {\\n        throw new Error(`The <Host> must be the single root component.\\nLooks like the render() function of \\"${hostTagName.toLowerCase()}\\" is returning an array that contains the <Host>.\\n\\nThe render() function should look like this instead:\\n\\nrender() {\\n  // Do not return an array\\n  return (\\n    <Host>{content}</Host>\\n  );\\n}\\n  `);\\n    }\\n    if (BUILD.reflect && cmpMeta.$attrsToReflect$) {\\n        rootVnode.$attrs$ = rootVnode.$attrs$ || {};\\n        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));\\n    }\\n    rootVnode.$tag$ = null;\\n    rootVnode.$flags$ |= 4 /* VNODE_FLAGS.isHost */;\\n    hostRef.$vnode$ = rootVnode;\\n    rootVnode.$elm$ = oldVNode.$elm$ = (BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm);\\n    if (BUILD.scoped || BUILD.shadowDom) {\\n        scopeId = hostElm[\'s-sc\'];\\n    }\\n    if (BUILD.slotRelocation) {\\n        contentRef = hostElm[\'s-cr\'];\\n        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) !== 0;\\n        // always reset\\n        checkSlotFallbackVisibility = false;\\n    }\\n    // synchronous patch\\n    patch(oldVNode, rootVnode);\\n    if (BUILD.slotRelocation) {\\n        // while we\'re moving nodes around existing nodes, temporarily disable\\n        // the disconnectCallback from working\\n        plt.$flags$ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;\\n        if (checkSlotRelocate) {\\n            relocateSlotContent(rootVnode.$elm$);\\n            let relocateData;\\n            let nodeToRelocate;\\n            let orgLocationNode;\\n            let parentNodeRef;\\n            let insertBeforeNode;\\n            let refNode;\\n            let i = 0;\\n            for (; i < relocateNodes.length; i++) {\\n                relocateData = relocateNodes[i];\\n                nodeToRelocate = relocateData.$nodeToRelocate$;\\n                if (!nodeToRelocate[\'s-ol\']) {\\n                    // add a reference node marking this node\'s original location\\n                    // keep a reference to this node for later lookups\\n                    orgLocationNode =\\n                        BUILD.isDebug || BUILD.hydrateServerSide\\n                            ? originalLocationDebugNode(nodeToRelocate)\\n                            : doc.createTextNode(\'\');\\n                    orgLocationNode[\'s-nr\'] = nodeToRelocate;\\n                    nodeToRelocate.parentNode.insertBefore((nodeToRelocate[\'s-ol\'] = orgLocationNode), nodeToRelocate);\\n                }\\n            }\\n            for (i = 0; i < relocateNodes.length; i++) {\\n                relocateData = relocateNodes[i];\\n                nodeToRelocate = relocateData.$nodeToRelocate$;\\n                if (relocateData.$slotRefNode$) {\\n                    // by default we\'re just going to insert it directly\\n                    // after the slot reference node\\n                    parentNodeRef = relocateData.$slotRefNode$.parentNode;\\n                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;\\n                    orgLocationNode = nodeToRelocate[\'s-ol\'];\\n                    while ((orgLocationNode = orgLocationNode.previousSibling)) {\\n                        refNode = orgLocationNode[\'s-nr\'];\\n                        if (refNode && refNode[\'s-sn\'] === nodeToRelocate[\'s-sn\'] && parentNodeRef === refNode.parentNode) {\\n                            refNode = refNode.nextSibling;\\n                            if (!refNode || !refNode[\'s-nr\']) {\\n                                insertBeforeNode = refNode;\\n                                break;\\n                            }\\n                        }\\n                    }\\n                    if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) ||\\n                        nodeToRelocate.nextSibling !== insertBeforeNode) {\\n                        // we\'ve checked that it\'s worth while to relocate\\n                        // since that the node to relocate\\n                        // has a different next sibling or parent relocated\\n                        if (nodeToRelocate !== insertBeforeNode) {\\n                            if (!nodeToRelocate[\'s-hn\'] && nodeToRelocate[\'s-ol\']) {\\n                                // probably a component in the index.html that doesn\'t have it\'s hostname set\\n                                nodeToRelocate[\'s-hn\'] = nodeToRelocate[\'s-ol\'].parentNode.nodeName;\\n                            }\\n                            // add it back to the dom but in its new home\\n                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);\\n                        }\\n                    }\\n                }\\n                else {\\n                    // this node doesn\'t have a slot home to go to, so let\'s hide it\\n                    if (nodeToRelocate.nodeType === 1 /* NODE_TYPE.ElementNode */) {\\n                        nodeToRelocate.hidden = true;\\n                    }\\n                }\\n            }\\n        }\\n        if (checkSlotFallbackVisibility) {\\n            updateFallbackSlotVisibility(rootVnode.$elm$);\\n        }\\n        // done moving nodes around\\n        // allow the disconnect callback to work again\\n        plt.$flags$ &= ~1 /* PLATFORM_FLAGS.isTmpDisconnected */;\\n        // always reset\\n        relocateNodes.length = 0;\\n    }\\n};\\n// slot comment debug nodes only created with the `--debug` flag\\n// otherwise these nodes are text nodes w/out content\\nconst slotReferenceDebugNode = (slotVNode) => doc.createComment(`<slot${slotVNode.$name$ ? \' name=\\"\' + slotVNode.$name$ + \'\\"\' : \'\'}> (host=${hostTagName.toLowerCase()})`);\\nconst originalLocationDebugNode = (nodeToRelocate) => doc.createComment(`org-location for ` +\\n    (nodeToRelocate.localName\\n        ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate[\'s-hn\']})`\\n        : `[${nodeToRelocate.textContent}]`));\\nconst attachToAncestor = (hostRef, ancestorComponent) => {\\n    if (BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent[\'s-p\']) {\\n        ancestorComponent[\'s-p\'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));\\n    }\\n};\\nconst scheduleUpdate = (hostRef, isInitialLoad) => {\\n    if (BUILD.taskQueue && BUILD.updatable) {\\n        hostRef.$flags$ |= 16 /* HOST_FLAGS.isQueuedForUpdate */;\\n    }\\n    if (BUILD.asyncLoading && hostRef.$flags$ & 4 /* HOST_FLAGS.isWaitingForChildren */) {\\n        hostRef.$flags$ |= 512 /* HOST_FLAGS.needsRerender */;\\n        return;\\n    }\\n    attachToAncestor(hostRef, hostRef.$ancestorComponent$);\\n    // there is no ancestor component or the ancestor component\\n    // has already fired off its lifecycle update then\\n    // fire off the initial update\\n    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\\n    return BUILD.taskQueue ? writeTask(dispatch) : dispatch();\\n};\\nconst dispatchHooks = (hostRef, isInitialLoad) => {\\n    const elm = hostRef.$hostElement$;\\n    const endSchedule = createTime(\'scheduleUpdate\', hostRef.$cmpMeta$.$tagName$);\\n    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\\n    let promise;\\n    if (isInitialLoad) {\\n        if (BUILD.lazyLoad && BUILD.hostListener) {\\n            hostRef.$flags$ |= 256 /* HOST_FLAGS.isListenReady */;\\n            if (hostRef.$queuedListeners$) {\\n                hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));\\n                hostRef.$queuedListeners$ = null;\\n            }\\n        }\\n        emitLifecycleEvent(elm, \'componentWillLoad\');\\n        if (BUILD.cmpWillLoad) {\\n            promise = safeCall(instance, \'componentWillLoad\');\\n        }\\n    }\\n    else {\\n        emitLifecycleEvent(elm, \'componentWillUpdate\');\\n        if (BUILD.cmpWillUpdate) {\\n            promise = safeCall(instance, \'componentWillUpdate\');\\n        }\\n    }\\n    emitLifecycleEvent(elm, \'componentWillRender\');\\n    if (BUILD.cmpWillRender) {\\n        promise = then(promise, () => safeCall(instance, \'componentWillRender\'));\\n    }\\n    endSchedule();\\n    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));\\n};\\nconst updateComponent = async (hostRef, instance, isInitialLoad) => {\\n    // updateComponent\\n    const elm = hostRef.$hostElement$;\\n    const endUpdate = createTime(\'update\', hostRef.$cmpMeta$.$tagName$);\\n    const rc = elm[\'s-rc\'];\\n    if (BUILD.style && isInitialLoad) {\\n        // DOM WRITE!\\n        attachStyles(hostRef);\\n    }\\n    const endRender = createTime(\'render\', hostRef.$cmpMeta$.$tagName$);\\n    if (BUILD.isDev) {\\n        hostRef.$flags$ |= 1024 /* HOST_FLAGS.devOnRender */;\\n    }\\n    if (BUILD.hydrateServerSide) {\\n        await callRender(hostRef, instance, elm);\\n    }\\n    else {\\n        callRender(hostRef, instance, elm);\\n    }\\n    if (BUILD.cssVarShim && plt.$cssShim$) {\\n        plt.$cssShim$.updateHost(elm);\\n    }\\n    if (BUILD.isDev) {\\n        hostRef.$renderCount$++;\\n        hostRef.$flags$ &= ~1024 /* HOST_FLAGS.devOnRender */;\\n    }\\n    if (BUILD.hydrateServerSide) {\\n        try {\\n            // manually connected child components during server-side hydrate\\n            serverSideConnected(elm);\\n            if (isInitialLoad) {\\n                // using only during server-side hydrate\\n                if (hostRef.$cmpMeta$.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {\\n                    elm[\'s-en\'] = \'\';\\n                }\\n                else if (hostRef.$cmpMeta$.$flags$ & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {\\n                    elm[\'s-en\'] = \'c\';\\n                }\\n            }\\n        }\\n        catch (e) {\\n            consoleError(e, elm);\\n        }\\n    }\\n    if (BUILD.asyncLoading && rc) {\\n        // ok, so turns out there are some child host elements\\n        // waiting on this parent element to load\\n        // let\'s fire off all update callbacks waiting\\n        rc.map((cb) => cb());\\n        elm[\'s-rc\'] = undefined;\\n    }\\n    endRender();\\n    endUpdate();\\n    if (BUILD.asyncLoading) {\\n        const childrenPromises = elm[\'s-p\'];\\n        const postUpdate = () => postUpdateComponent(hostRef);\\n        if (childrenPromises.length === 0) {\\n            postUpdate();\\n        }\\n        else {\\n            Promise.all(childrenPromises).then(postUpdate);\\n            hostRef.$flags$ |= 4 /* HOST_FLAGS.isWaitingForChildren */;\\n            childrenPromises.length = 0;\\n        }\\n    }\\n    else {\\n        postUpdateComponent(hostRef);\\n    }\\n};\\nconst callRender = (hostRef, instance, elm) => {\\n    // in order for bundlers to correctly treeshake the BUILD object\\n    // we need to ensure BUILD is not deoptimized within a try/catch\\n    // https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization\\n    const allRenderFn = BUILD.allRenderFn ? true : false;\\n    const lazyLoad = BUILD.lazyLoad ? true : false;\\n    const taskQueue = BUILD.taskQueue ? true : false;\\n    const updatable = BUILD.updatable ? true : false;\\n    try {\\n        renderingRef = instance;\\n        instance = allRenderFn ? instance.render() : instance.render && instance.render();\\n        if (updatable && taskQueue) {\\n            hostRef.$flags$ &= ~16 /* HOST_FLAGS.isQueuedForUpdate */;\\n        }\\n        if (updatable || lazyLoad) {\\n            hostRef.$flags$ |= 2 /* HOST_FLAGS.hasRendered */;\\n        }\\n        if (BUILD.hasRenderFn || BUILD.reflect) {\\n            if (BUILD.vdomRender || BUILD.reflect) {\\n                // looks like we\'ve got child nodes to render into this host element\\n                // or we need to update the css class/attrs on the host element\\n                // DOM WRITE!\\n                if (BUILD.hydrateServerSide) {\\n                    return Promise.resolve(instance).then((value) => renderVdom(hostRef, value));\\n                }\\n                else {\\n                    renderVdom(hostRef, instance);\\n                }\\n            }\\n            else {\\n                elm.textContent = instance;\\n            }\\n        }\\n    }\\n    catch (e) {\\n        consoleError(e, hostRef.$hostElement$);\\n    }\\n    renderingRef = null;\\n    return null;\\n};\\nconst getRenderingRef = () => renderingRef;\\nconst postUpdateComponent = (hostRef) => {\\n    const tagName = hostRef.$cmpMeta$.$tagName$;\\n    const elm = hostRef.$hostElement$;\\n    const endPostUpdate = createTime(\'postUpdate\', tagName);\\n    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\\n    const ancestorComponent = hostRef.$ancestorComponent$;\\n    if (BUILD.cmpDidRender) {\\n        if (BUILD.isDev) {\\n            hostRef.$flags$ |= 1024 /* HOST_FLAGS.devOnRender */;\\n        }\\n        safeCall(instance, \'componentDidRender\');\\n        if (BUILD.isDev) {\\n            hostRef.$flags$ &= ~1024 /* HOST_FLAGS.devOnRender */;\\n        }\\n    }\\n    emitLifecycleEvent(elm, \'componentDidRender\');\\n    if (!(hostRef.$flags$ & 64 /* HOST_FLAGS.hasLoadedComponent */)) {\\n        hostRef.$flags$ |= 64 /* HOST_FLAGS.hasLoadedComponent */;\\n        if (BUILD.asyncLoading && BUILD.cssAnnotations) {\\n            // DOM WRITE!\\n            addHydratedFlag(elm);\\n        }\\n        if (BUILD.cmpDidLoad) {\\n            if (BUILD.isDev) {\\n                hostRef.$flags$ |= 2048 /* HOST_FLAGS.devOnDidLoad */;\\n            }\\n            safeCall(instance, \'componentDidLoad\');\\n            if (BUILD.isDev) {\\n                hostRef.$flags$ &= ~2048 /* HOST_FLAGS.devOnDidLoad */;\\n            }\\n        }\\n        emitLifecycleEvent(elm, \'componentDidLoad\');\\n        endPostUpdate();\\n        if (BUILD.asyncLoading) {\\n            hostRef.$onReadyResolve$(elm);\\n            if (!ancestorComponent) {\\n                appDidLoad(tagName);\\n            }\\n        }\\n    }\\n    else {\\n        if (BUILD.cmpDidUpdate) {\\n            // we\'ve already loaded this component\\n            // fire off the user\'s componentDidUpdate method (if one was provided)\\n            // componentDidUpdate runs AFTER render() has been called\\n            // and all child components have finished updating\\n            if (BUILD.isDev) {\\n                hostRef.$flags$ |= 1024 /* HOST_FLAGS.devOnRender */;\\n            }\\n            safeCall(instance, \'componentDidUpdate\');\\n            if (BUILD.isDev) {\\n                hostRef.$flags$ &= ~1024 /* HOST_FLAGS.devOnRender */;\\n            }\\n        }\\n        emitLifecycleEvent(elm, \'componentDidUpdate\');\\n        endPostUpdate();\\n    }\\n    if (BUILD.hotModuleReplacement) {\\n        elm[\'s-hmr-load\'] && elm[\'s-hmr-load\']();\\n    }\\n    if (BUILD.method && BUILD.lazyLoad) {\\n        hostRef.$onInstanceResolve$(elm);\\n    }\\n    // load events fire from bottom to top\\n    // the deepest elements load first then bubbles up\\n    if (BUILD.asyncLoading) {\\n        if (hostRef.$onRenderResolve$) {\\n            hostRef.$onRenderResolve$();\\n            hostRef.$onRenderResolve$ = undefined;\\n        }\\n        if (hostRef.$flags$ & 512 /* HOST_FLAGS.needsRerender */) {\\n            nextTick(() => scheduleUpdate(hostRef, false));\\n        }\\n        hostRef.$flags$ &= ~(4 /* HOST_FLAGS.isWaitingForChildren */ | 512 /* HOST_FLAGS.needsRerender */);\\n    }\\n    // ( _)\\n    // ( _)>-\\n    // (_)\\n};\\nconst forceUpdate = (ref) => {\\n    if (BUILD.updatable) {\\n        const hostRef = getHostRef(ref);\\n        const isConnected = hostRef.$hostElement$.isConnected;\\n        if (isConnected &&\\n            (hostRef.$flags$ & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {\\n            scheduleUpdate(hostRef, false);\\n        }\\n        // Returns \\"true\\" when the forced update was successfully scheduled\\n        return isConnected;\\n    }\\n    return false;\\n};\\nconst appDidLoad = (who) => {\\n    // on appload\\n    // we have finish the first big initial render\\n    if (BUILD.cssAnnotations) {\\n        addHydratedFlag(doc.documentElement);\\n    }\\n    if (BUILD.asyncQueue) {\\n        plt.$flags$ |= 2 /* PLATFORM_FLAGS.appLoaded */;\\n    }\\n    nextTick(() => emitEvent(win, \'appload\', { detail: { namespace: NAMESPACE } }));\\n    if (BUILD.profile && performance.measure) {\\n        performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${who})`, \'st:app:start\');\\n    }\\n};\\nconst safeCall = (instance, method, arg) => {\\n    if (instance && instance[method]) {\\n        try {\\n            return instance[method](arg);\\n        }\\n        catch (e) {\\n            consoleError(e);\\n        }\\n    }\\n    return undefined;\\n};\\nconst then = (promise, thenFn) => {\\n    return promise && promise.then ? promise.then(thenFn) : thenFn();\\n};\\nconst emitLifecycleEvent = (elm, lifecycleName) => {\\n    if (BUILD.lifecycleDOMEvents) {\\n        emitEvent(elm, \'stencil_\' + lifecycleName, {\\n            bubbles: true,\\n            composed: true,\\n            detail: {\\n                namespace: NAMESPACE,\\n            },\\n        });\\n    }\\n};\\nconst addHydratedFlag = (elm) => BUILD.hydratedClass\\n    ? elm.classList.add(\'hydrated\')\\n    : BUILD.hydratedAttribute\\n        ? elm.setAttribute(\'hydrated\', \'\')\\n        : undefined;\\nconst serverSideConnected = (elm) => {\\n    const children = elm.children;\\n    if (children != null) {\\n        for (let i = 0, ii = children.length; i < ii; i++) {\\n            const childElm = children[i];\\n            if (typeof childElm.connectedCallback === \'function\') {\\n                childElm.connectedCallback();\\n            }\\n            serverSideConnected(childElm);\\n        }\\n    }\\n};\\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\\nconst setValue = (ref, propName, newVal, cmpMeta) => {\\n    // check our new property value against our internal value\\n    const hostRef = getHostRef(ref);\\n    const elm = BUILD.lazyLoad ? hostRef.$hostElement$ : ref;\\n    const oldVal = hostRef.$instanceValues$.get(propName);\\n    const flags = hostRef.$flags$;\\n    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\\n    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\\n    // explicitly check for NaN on both sides, as `NaN === NaN` is always false\\n    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\\n    const didValueChange = newVal !== oldVal && !areBothNaN;\\n    if ((!BUILD.lazyLoad || !(flags & 8 /* HOST_FLAGS.isConstructingInstance */) || oldVal === undefined) && didValueChange) {\\n        // gadzooks! the property\'s value has changed!!\\n        // set our new value!\\n        hostRef.$instanceValues$.set(propName, newVal);\\n        if (BUILD.isDev) {\\n            if (hostRef.$flags$ & 1024 /* HOST_FLAGS.devOnRender */) {\\n                consoleDevWarn(`The state/prop \\"${propName}\\" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, \'\\\\nElement\', elm, \'\\\\nNew value\', newVal, \'\\\\nOld value\', oldVal);\\n            }\\n            else if (hostRef.$flags$ & 2048 /* HOST_FLAGS.devOnDidLoad */) {\\n                consoleDevWarn(`The state/prop \\"${propName}\\" changed during \\"componentDidLoad()\\", this triggers extra re-renders, try to setup on \\"componentWillLoad()\\"`, \'\\\\nElement\', elm, \'\\\\nNew value\', newVal, \'\\\\nOld value\', oldVal);\\n            }\\n        }\\n        if (!BUILD.lazyLoad || instance) {\\n            // get an array of method names of watch functions to call\\n            if (BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* HOST_FLAGS.isWatchReady */) {\\n                const watchMethods = cmpMeta.$watchers$[propName];\\n                if (watchMethods) {\\n                    // this instance is watching for when this property changed\\n                    watchMethods.map((watchMethodName) => {\\n                        try {\\n                            // fire off each of the watch methods that are watching this property\\n                            instance[watchMethodName](newVal, oldVal, propName);\\n                        }\\n                        catch (e) {\\n                            consoleError(e, elm);\\n                        }\\n                    });\\n                }\\n            }\\n            if (BUILD.updatable &&\\n                (flags & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {\\n                if (BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {\\n                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\\n                        return;\\n                    }\\n                }\\n                // looks like this value actually changed, so we\'ve got work to do!\\n                // but only if we\'ve already rendered, otherwise just chill out\\n                // queue that we need to do an update, but don\'t worry about queuing\\n                // up millions cuz this function ensures it only runs once\\n                scheduleUpdate(hostRef, false);\\n            }\\n        }\\n    }\\n};\\n/**\\n * Attach a series of runtime constructs to a compiled Stencil component\\n * constructor, including getters and setters for the `@Prop` and `@State`\\n * decorators, callbacks for when attributes change, and so on.\\n *\\n * @param Cstr the constructor for a component that we need to process\\n * @param cmpMeta metadata collected previously about the component\\n * @param flags a number used to store a series of bit flags\\n * @returns a reference to the same constructor passed in (but now mutated)\\n */\\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\\n    if (BUILD.member && cmpMeta.$members$) {\\n        if (BUILD.watchCallback && Cstr.watchers) {\\n            cmpMeta.$watchers$ = Cstr.watchers;\\n        }\\n        // It\'s better to have a const than two Object.entries()\\n        const members = Object.entries(cmpMeta.$members$);\\n        const prototype = Cstr.prototype;\\n        members.map(([memberName, [memberFlags]]) => {\\n            if ((BUILD.prop || BUILD.state) &&\\n                (memberFlags & 31 /* MEMBER_FLAGS.Prop */ ||\\n                    ((!BUILD.lazyLoad || flags & 2 /* PROXY_FLAGS.proxyState */) && memberFlags & 32 /* MEMBER_FLAGS.State */))) {\\n                // proxyComponent - prop\\n                Object.defineProperty(prototype, memberName, {\\n                    get() {\\n                        // proxyComponent, get value\\n                        return getValue(this, memberName);\\n                    },\\n                    set(newValue) {\\n                        // only during dev time\\n                        if (BUILD.isDev) {\\n                            const ref = getHostRef(this);\\n                            if (\\n                            // we are proxying the instance (not element)\\n                            (flags & 1 /* PROXY_FLAGS.isElementConstructor */) === 0 &&\\n                                // the element is not constructing\\n                                (ref.$flags$ & 8 /* HOST_FLAGS.isConstructingInstance */) === 0 &&\\n                                // the member is a prop\\n                                (memberFlags & 31 /* MEMBER_FLAGS.Prop */) !== 0 &&\\n                                // the member is not mutable\\n                                (memberFlags & 1024 /* MEMBER_FLAGS.Mutable */) === 0) {\\n                                consoleDevWarn(`@Prop() \\"${memberName}\\" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\\\\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);\\n                            }\\n                        }\\n                        // proxyComponent, set value\\n                        setValue(this, memberName, newValue, cmpMeta);\\n                    },\\n                    configurable: true,\\n                    enumerable: true,\\n                });\\n            }\\n            else if (BUILD.lazyLoad &&\\n                BUILD.method &&\\n                flags & 1 /* PROXY_FLAGS.isElementConstructor */ &&\\n                memberFlags & 64 /* MEMBER_FLAGS.Method */) {\\n                // proxyComponent - method\\n                Object.defineProperty(prototype, memberName, {\\n                    value(...args) {\\n                        const ref = getHostRef(this);\\n                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));\\n                    },\\n                });\\n            }\\n        });\\n        if (BUILD.observeAttribute && (!BUILD.lazyLoad || flags & 1 /* PROXY_FLAGS.isElementConstructor */)) {\\n            const attrNameToPropName = new Map();\\n            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\\n                plt.jmp(() => {\\n                    const propName = attrNameToPropName.get(attrName);\\n                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback\\n                    //  in the case where an attribute was set inline.\\n                    //  ```html\\n                    //    <my-component some-attribute=\\"some-value\\"></my-component>\\n                    //  ```\\n                    //\\n                    //  There is an edge case where a developer sets the attribute inline on a custom element and then\\n                    //  programmatically changes it before it has been upgraded as shown below:\\n                    //\\n                    //  ```html\\n                    //    \x3c!-- this component has _not_ been upgraded yet --\x3e\\n                    //    <my-component id=\\"test\\" some-attribute=\\"some-value\\"></my-component>\\n                    //    <script>\\n                    //      // grab non-upgraded component\\n                    //      el = document.querySelector(\\"#test\\");\\n                    //      el.someAttribute = \\"another-value\\";\\n                    //      // upgrade component\\n                    //      customElements.define(\'my-component\', MyComponent);\\n                    //    <\/script>\\n                    //  ```\\n                    //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback\\n                    //  will be called with `newValue = \\"some-value\\"` and will set the shadowed property (this.someAttribute = \\"another-value\\")\\n                    //  to the value that was set inline i.e. \\"some-value\\" from above example. When\\n                    //  the connectedCallback attempts to unshadow it will use \\"some-value\\" as the initial value rather than \\"another-value\\"\\n                    //\\n                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed\\n                    //  by connectedCallback as this attributeChangedCallback will not fire.\\n                    //\\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\\n                    //\\n                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to\\n                    //  properties here given that this goes against best practices outlined here\\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy\\n                    if (this.hasOwnProperty(propName)) {\\n                        newValue = this[propName];\\n                        delete this[propName];\\n                    }\\n                    else if (prototype.hasOwnProperty(propName) &&\\n                        typeof this[propName] === \'number\' &&\\n                        this[propName] == newValue) {\\n                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native\\n                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in\\n                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.\\n                        return;\\n                    }\\n                    this[propName] = newValue === null && typeof this[propName] === \'boolean\' ? false : newValue;\\n                });\\n            };\\n            // create an array of attributes to observe\\n            // and also create a map of html attribute name to js property name\\n            Cstr.observedAttributes = members\\n                .filter(([_, m]) => m[0] & 15 /* MEMBER_FLAGS.HasAttribute */) // filter to only keep props that should match attributes\\n                .map(([propName, m]) => {\\n                const attrName = m[1] || propName;\\n                attrNameToPropName.set(attrName, propName);\\n                if (BUILD.reflect && m[0] & 512 /* MEMBER_FLAGS.ReflectAttr */) {\\n                    cmpMeta.$attrsToReflect$.push([propName, attrName]);\\n                }\\n                return attrName;\\n            });\\n        }\\n    }\\n    return Cstr;\\n};\\nconst initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {\\n    // initializeComponent\\n    if ((BUILD.lazyLoad || BUILD.hydrateServerSide || BUILD.style) &&\\n        (hostRef.$flags$ & 32 /* HOST_FLAGS.hasInitializedComponent */) === 0) {\\n        if (BUILD.lazyLoad || BUILD.hydrateClientSide) {\\n            // we haven\'t initialized this element yet\\n            hostRef.$flags$ |= 32 /* HOST_FLAGS.hasInitializedComponent */;\\n            // lazy loaded components\\n            // request the component\'s implementation to be\\n            // wired up with the host element\\n            Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);\\n            if (Cstr.then) {\\n                // Await creates a micro-task avoid if possible\\n                const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);\\n                Cstr = await Cstr;\\n                endLoad();\\n            }\\n            if ((BUILD.isDev || BUILD.isDebug) && !Cstr) {\\n                throw new Error(`Constructor for \\"${cmpMeta.$tagName$}#${hostRef.$modeName$}\\" was not found`);\\n            }\\n            if (BUILD.member && !Cstr.isProxied) {\\n                // we\'ve never proxied this Constructor before\\n                // let\'s add the getters/setters to its prototype before\\n                // the first time we create an instance of the implementation\\n                if (BUILD.watchCallback) {\\n                    cmpMeta.$watchers$ = Cstr.watchers;\\n                }\\n                proxyComponent(Cstr, cmpMeta, 2 /* PROXY_FLAGS.proxyState */);\\n                Cstr.isProxied = true;\\n            }\\n            const endNewInstance = createTime(\'createInstance\', cmpMeta.$tagName$);\\n            // ok, time to construct the instance\\n            // but let\'s keep track of when we start and stop\\n            // so that the getters/setters don\'t incorrectly step on data\\n            if (BUILD.member) {\\n                hostRef.$flags$ |= 8 /* HOST_FLAGS.isConstructingInstance */;\\n            }\\n            // construct the lazy-loaded component implementation\\n            // passing the hostRef is very important during\\n            // construction in order to directly wire together the\\n            // host element and the lazy-loaded instance\\n            try {\\n                new Cstr(hostRef);\\n            }\\n            catch (e) {\\n                consoleError(e);\\n            }\\n            if (BUILD.member) {\\n                hostRef.$flags$ &= ~8 /* HOST_FLAGS.isConstructingInstance */;\\n            }\\n            if (BUILD.watchCallback) {\\n                hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */;\\n            }\\n            endNewInstance();\\n            fireConnectedCallback(hostRef.$lazyInstance$);\\n        }\\n        else {\\n            // sync constructor component\\n            Cstr = elm.constructor;\\n            hostRef.$flags$ |= 32 /* HOST_FLAGS.hasInitializedComponent */;\\n            // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,\\n            // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_\\n            // Stencil has completed instantiating the component.\\n            customElements.whenDefined(cmpMeta.$tagName$).then(() => (hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */));\\n        }\\n        if (BUILD.style && Cstr.style) {\\n            // this component has styles but we haven\'t registered them yet\\n            let style = Cstr.style;\\n            if (BUILD.mode && typeof style !== \'string\') {\\n                style = style[(hostRef.$modeName$ = computeMode(elm))];\\n                if (BUILD.hydrateServerSide && hostRef.$modeName$) {\\n                    elm.setAttribute(\'s-mode\', hostRef.$modeName$);\\n                }\\n            }\\n            const scopeId = getScopeId(cmpMeta, hostRef.$modeName$);\\n            if (!styles.has(scopeId)) {\\n                const endRegisterStyles = createTime(\'registerStyles\', cmpMeta.$tagName$);\\n                if (!BUILD.hydrateServerSide &&\\n                    BUILD.shadowDom &&\\n                    BUILD.shadowDomShim &&\\n                    cmpMeta.$flags$ & 8 /* CMP_FLAGS.needsShadowDomShim */) {\\n                    style = await import(\'./shadow-css.js\').then((m) => m.scopeCss(style, scopeId, false));\\n                }\\n                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */));\\n                endRegisterStyles();\\n            }\\n        }\\n    }\\n    // we\'ve successfully created a lazy instance\\n    const ancestorComponent = hostRef.$ancestorComponent$;\\n    const schedule = () => scheduleUpdate(hostRef, true);\\n    if (BUILD.asyncLoading && ancestorComponent && ancestorComponent[\'s-rc\']) {\\n        // this is the initial load and this component it has an ancestor component\\n        // but the ancestor component has NOT fired its will update lifecycle yet\\n        // so let\'s just cool our jets and wait for the ancestor to continue first\\n        // this will get fired off when the ancestor component\\n        // finally gets around to rendering its lazy self\\n        // fire off the initial update\\n        ancestorComponent[\'s-rc\'].push(schedule);\\n    }\\n    else {\\n        schedule();\\n    }\\n};\\nconst fireConnectedCallback = (instance) => {\\n    if (BUILD.lazyLoad && BUILD.connectedCallback) {\\n        safeCall(instance, \'connectedCallback\');\\n    }\\n};\\nconst connectedCallback = (elm) => {\\n    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {\\n        const hostRef = getHostRef(elm);\\n        const cmpMeta = hostRef.$cmpMeta$;\\n        const endConnected = createTime(\'connectedCallback\', cmpMeta.$tagName$);\\n        if (BUILD.hostListenerTargetParent) {\\n            // only run if we have listeners being attached to a parent\\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);\\n        }\\n        if (!(hostRef.$flags$ & 1 /* HOST_FLAGS.hasConnected */)) {\\n            // first time this component has connected\\n            hostRef.$flags$ |= 1 /* HOST_FLAGS.hasConnected */;\\n            let hostId;\\n            if (BUILD.hydrateClientSide) {\\n                hostId = elm.getAttribute(HYDRATE_ID);\\n                if (hostId) {\\n                    if (BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {\\n                        const scopeId = BUILD.mode\\n                            ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute(\'s-mode\'))\\n                            : addStyle(elm.shadowRoot, cmpMeta);\\n                        elm.classList.remove(scopeId + \'-h\', scopeId + \'-s\');\\n                    }\\n                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);\\n                }\\n            }\\n            if (BUILD.slotRelocation && !hostId) {\\n                // initUpdate\\n                // if the slot polyfill is required we\'ll need to put some nodes\\n                // in here to act as original content anchors as we move nodes around\\n                // host element has been connected to the DOM\\n                if (BUILD.hydrateServerSide ||\\n                    ((BUILD.slot || BUILD.shadowDom) &&\\n                        cmpMeta.$flags$ & (4 /* CMP_FLAGS.hasSlotRelocation */ | 8 /* CMP_FLAGS.needsShadowDomShim */))) {\\n                    setContentReference(elm);\\n                }\\n            }\\n            if (BUILD.asyncLoading) {\\n                // find the first ancestor component (if there is one) and register\\n                // this component as one of the actively loading child components for its ancestor\\n                let ancestorComponent = elm;\\n                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {\\n                    // climb up the ancestors looking for the first\\n                    // component that hasn\'t finished its lifecycle update yet\\n                    if ((BUILD.hydrateClientSide &&\\n                        ancestorComponent.nodeType === 1 /* NODE_TYPE.ElementNode */ &&\\n                        ancestorComponent.hasAttribute(\'s-id\') &&\\n                        ancestorComponent[\'s-p\']) ||\\n                        ancestorComponent[\'s-p\']) {\\n                        // we found this components first ancestor component\\n                        // keep a reference to this component\'s ancestor component\\n                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));\\n                        break;\\n                    }\\n                }\\n            }\\n            // Lazy properties\\n            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\\n            if (BUILD.prop && !BUILD.hydrateServerSide && cmpMeta.$members$) {\\n                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\\n                    if (memberFlags & 31 /* MEMBER_FLAGS.Prop */ && elm.hasOwnProperty(memberName)) {\\n                        const value = elm[memberName];\\n                        delete elm[memberName];\\n                        elm[memberName] = value;\\n                    }\\n                });\\n            }\\n            if (BUILD.initializeNextTick) {\\n                // connectedCallback, taskQueue, initialLoad\\n                // angular sets attribute AFTER connectCallback\\n                // https://github.com/angular/angular/issues/18909\\n                // https://github.com/angular/angular/issues/19940\\n                nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\\n            }\\n            else {\\n                initializeComponent(elm, hostRef, cmpMeta);\\n            }\\n        }\\n        else {\\n            // not the first time this has connected\\n            // reattach any event listeners to the host\\n            // since they would have been removed when disconnected\\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\\n            // fire off connectedCallback() on component instance\\n            fireConnectedCallback(hostRef.$lazyInstance$);\\n        }\\n        endConnected();\\n    }\\n};\\nconst setContentReference = (elm) => {\\n    // only required when we\'re NOT using native shadow dom (slot)\\n    // or this browser doesn\'t support native shadow dom\\n    // and this host element was NOT created with SSR\\n    // let\'s pick out the inner content for slot projection\\n    // create a node to represent where the original\\n    // content was first placed, which is useful later on\\n    const contentRefElm = (elm[\'s-cr\'] = doc.createComment(BUILD.isDebug ? `content-ref (host=${elm.localName})` : \'\'));\\n    contentRefElm[\'s-cn\'] = true;\\n    elm.insertBefore(contentRefElm, elm.firstChild);\\n};\\nconst disconnectedCallback = (elm) => {\\n    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {\\n        const hostRef = getHostRef(elm);\\n        const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\\n        if (BUILD.hostListener) {\\n            if (hostRef.$rmListeners$) {\\n                hostRef.$rmListeners$.map((rmListener) => rmListener());\\n                hostRef.$rmListeners$ = undefined;\\n            }\\n        }\\n        // clear CSS var-shim tracking\\n        if (BUILD.cssVarShim && plt.$cssShim$) {\\n            plt.$cssShim$.removeHost(elm);\\n        }\\n        if (BUILD.lazyLoad && BUILD.disconnectedCallback) {\\n            safeCall(instance, \'disconnectedCallback\');\\n        }\\n        if (BUILD.cmpDidUnload) {\\n            safeCall(instance, \'componentDidUnload\');\\n        }\\n    }\\n};\\nconst defineCustomElement = (Cstr, compactMeta) => {\\n    customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));\\n};\\nconst proxyCustomElement = (Cstr, compactMeta) => {\\n    const cmpMeta = {\\n        $flags$: compactMeta[0],\\n        $tagName$: compactMeta[1],\\n    };\\n    if (BUILD.member) {\\n        cmpMeta.$members$ = compactMeta[2];\\n    }\\n    if (BUILD.hostListener) {\\n        cmpMeta.$listeners$ = compactMeta[3];\\n    }\\n    if (BUILD.watchCallback) {\\n        cmpMeta.$watchers$ = Cstr.$watchers$;\\n    }\\n    if (BUILD.reflect) {\\n        cmpMeta.$attrsToReflect$ = [];\\n    }\\n    if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {\\n        cmpMeta.$flags$ |= 8 /* CMP_FLAGS.needsShadowDomShim */;\\n    }\\n    const originalConnectedCallback = Cstr.prototype.connectedCallback;\\n    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\\n    Object.assign(Cstr.prototype, {\\n        __registerHost() {\\n            registerHost(this, cmpMeta);\\n        },\\n        connectedCallback() {\\n            connectedCallback(this);\\n            if (BUILD.connectedCallback && originalConnectedCallback) {\\n                originalConnectedCallback.call(this);\\n            }\\n        },\\n        disconnectedCallback() {\\n            disconnectedCallback(this);\\n            if (BUILD.disconnectedCallback && originalDisconnectedCallback) {\\n                originalDisconnectedCallback.call(this);\\n            }\\n        },\\n        __attachShadow() {\\n            if (supportsShadow) {\\n                if (BUILD.shadowDelegatesFocus) {\\n                    this.attachShadow({\\n                        mode: \'open\',\\n                        delegatesFocus: !!(cmpMeta.$flags$ & 16 /* CMP_FLAGS.shadowDelegatesFocus */),\\n                    });\\n                }\\n                else {\\n                    this.attachShadow({ mode: \'open\' });\\n                }\\n            }\\n            else {\\n                this.shadowRoot = this;\\n            }\\n        },\\n    });\\n    Cstr.is = cmpMeta.$tagName$;\\n    return proxyComponent(Cstr, cmpMeta, 1 /* PROXY_FLAGS.isElementConstructor */ | 2 /* PROXY_FLAGS.proxyState */);\\n};\\nconst forceModeUpdate = (elm) => {\\n    if (BUILD.style && BUILD.mode && !BUILD.lazyLoad) {\\n        const mode = computeMode(elm);\\n        const hostRef = getHostRef(elm);\\n        if (hostRef.$modeName$ !== mode) {\\n            const cmpMeta = hostRef.$cmpMeta$;\\n            const oldScopeId = elm[\'s-sc\'];\\n            const scopeId = getScopeId(cmpMeta, mode);\\n            const style = elm.constructor.style[mode];\\n            const flags = cmpMeta.$flags$;\\n            if (style) {\\n                if (!styles.has(scopeId)) {\\n                    registerStyle(scopeId, style, !!(flags & 1 /* CMP_FLAGS.shadowDomEncapsulation */));\\n                }\\n                hostRef.$modeName$ = mode;\\n                elm.classList.remove(oldScopeId + \'-h\', oldScopeId + \'-s\');\\n                attachStyles(hostRef);\\n                forceUpdate(elm);\\n            }\\n        }\\n    }\\n};\\nconst patchCloneNode = (HostElementPrototype) => {\\n    const orgCloneNode = HostElementPrototype.cloneNode;\\n    HostElementPrototype.cloneNode = function (deep) {\\n        const srcNode = this;\\n        const isShadowDom = BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;\\n        const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);\\n        if (BUILD.slot && !isShadowDom && deep) {\\n            let i = 0;\\n            let slotted, nonStencilNode;\\n            const stencilPrivates = [\\n                \'s-id\',\\n                \'s-cr\',\\n                \'s-lr\',\\n                \'s-rc\',\\n                \'s-sc\',\\n                \'s-p\',\\n                \'s-cn\',\\n                \'s-sr\',\\n                \'s-sn\',\\n                \'s-hn\',\\n                \'s-ol\',\\n                \'s-nr\',\\n                \'s-si\',\\n            ];\\n            for (; i < srcNode.childNodes.length; i++) {\\n                slotted = srcNode.childNodes[i][\'s-nr\'];\\n                nonStencilNode = stencilPrivates.every((privateField) => !srcNode.childNodes[i][privateField]);\\n                if (slotted) {\\n                    if (BUILD.appendChildSlotFix && clonedNode.__appendChild) {\\n                        clonedNode.__appendChild(slotted.cloneNode(true));\\n                    }\\n                    else {\\n                        clonedNode.appendChild(slotted.cloneNode(true));\\n                    }\\n                }\\n                if (nonStencilNode) {\\n                    clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));\\n                }\\n            }\\n        }\\n        return clonedNode;\\n    };\\n};\\nconst patchSlotAppendChild = (HostElementPrototype) => {\\n    HostElementPrototype.__appendChild = HostElementPrototype.appendChild;\\n    HostElementPrototype.appendChild = function (newChild) {\\n        const slotName = (newChild[\'s-sn\'] = getSlotName(newChild));\\n        const slotNode = getHostSlotNode(this.childNodes, slotName);\\n        if (slotNode) {\\n            const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\\n            const appendAfter = slotChildNodes[slotChildNodes.length - 1];\\n            return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);\\n        }\\n        return this.__appendChild(newChild);\\n    };\\n};\\n/**\\n * Patches the text content of an unnamed slotted node inside a scoped component\\n * @param hostElementPrototype the `Element` to be patched\\n * @param cmpMeta component runtime metadata used to determine if the component should be patched or not\\n */\\nconst patchTextContent = (hostElementPrototype, cmpMeta) => {\\n    if (BUILD.scoped && cmpMeta.$flags$ & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {\\n        const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, \'textContent\');\\n        Object.defineProperty(hostElementPrototype, \'__textContent\', descriptor);\\n        Object.defineProperty(hostElementPrototype, \'textContent\', {\\n            get() {\\n                var _a;\\n                // get the \'default slot\', which would be the first slot in a shadow tree (if we were using one), whose name is\\n                // the empty string\\n                const slotNode = getHostSlotNode(this.childNodes, \'\');\\n                // when a slot node is found, the textContent _may_ be found in the next sibling (text) node, depending on how\\n                // nodes were reordered during the vdom render. first try to get the text content from the sibling.\\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* NODE_TYPES.TEXT_NODE */) {\\n                    return slotNode.nextSibling.textContent;\\n                }\\n                else if (slotNode) {\\n                    return slotNode.textContent;\\n                }\\n                else {\\n                    // fallback to the original implementation\\n                    return this.__textContent;\\n                }\\n            },\\n            set(value) {\\n                var _a;\\n                // get the \'default slot\', which would be the first slot in a shadow tree (if we were using one), whose name is\\n                // the empty string\\n                const slotNode = getHostSlotNode(this.childNodes, \'\');\\n                // when a slot node is found, the textContent _may_ need to be placed in the next sibling (text) node,\\n                // depending on how nodes were reordered during the vdom render. first try to set the text content on the\\n                // sibling.\\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* NODE_TYPES.TEXT_NODE */) {\\n                    slotNode.nextSibling.textContent = value;\\n                }\\n                else if (slotNode) {\\n                    slotNode.textContent = value;\\n                }\\n                else {\\n                    // we couldn\'t find a slot, but that doesn\'t mean that there isn\'t one. if this check ran before the DOM\\n                    // loaded, we could have missed it. check for a content reference element on the scoped component and insert\\n                    // it there\\n                    this.__textContent = value;\\n                    const contentRefElm = this[\'s-cr\'];\\n                    if (contentRefElm) {\\n                        this.insertBefore(contentRefElm, this.firstChild);\\n                    }\\n                }\\n            },\\n        });\\n    }\\n};\\nconst patchChildSlotNodes = (elm, cmpMeta) => {\\n    class FakeNodeList extends Array {\\n        item(n) {\\n            return this[n];\\n        }\\n    }\\n    if (cmpMeta.$flags$ & 8 /* CMP_FLAGS.needsShadowDomShim */) {\\n        const childNodesFn = elm.__lookupGetter__(\'childNodes\');\\n        Object.defineProperty(elm, \'children\', {\\n            get() {\\n                return this.childNodes.map((n) => n.nodeType === 1);\\n            },\\n        });\\n        Object.defineProperty(elm, \'childElementCount\', {\\n            get() {\\n                return elm.children.length;\\n            },\\n        });\\n        Object.defineProperty(elm, \'childNodes\', {\\n            get() {\\n                const childNodes = childNodesFn.call(this);\\n                if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0 &&\\n                    getHostRef(this).$flags$ & 2 /* HOST_FLAGS.hasRendered */) {\\n                    const result = new FakeNodeList();\\n                    for (let i = 0; i < childNodes.length; i++) {\\n                        const slot = childNodes[i][\'s-nr\'];\\n                        if (slot) {\\n                            result.push(slot);\\n                        }\\n                    }\\n                    return result;\\n                }\\n                return FakeNodeList.from(childNodes);\\n            },\\n        });\\n    }\\n};\\nconst getSlotName = (node) => node[\'s-sn\'] || (node.nodeType === 1 && node.getAttribute(\'slot\')) || \'\';\\n/**\\n * Recursively searches a series of child nodes for a slot with the provided name.\\n * @param childNodes the nodes to search for a slot with a specific name.\\n * @param slotName the name of the slot to match on.\\n * @returns a reference to the slot node that matches the provided name, `null` otherwise\\n */\\nconst getHostSlotNode = (childNodes, slotName) => {\\n    let i = 0;\\n    let childNode;\\n    for (; i < childNodes.length; i++) {\\n        childNode = childNodes[i];\\n        if (childNode[\'s-sr\'] && childNode[\'s-sn\'] === slotName) {\\n            return childNode;\\n        }\\n        childNode = getHostSlotNode(childNode.childNodes, slotName);\\n        if (childNode) {\\n            return childNode;\\n        }\\n    }\\n    return null;\\n};\\nconst getHostSlotChildNodes = (n, slotName) => {\\n    const childNodes = [n];\\n    while ((n = n.nextSibling) && n[\'s-sn\'] === slotName) {\\n        childNodes.push(n);\\n    }\\n    return childNodes;\\n};\\nconst hmrStart = (elm, cmpMeta, hmrVersionId) => {\\n    // \\\\_()_/\\n    const hostRef = getHostRef(elm);\\n    // reset state flags to only have been connected\\n    hostRef.$flags$ = 1 /* HOST_FLAGS.hasConnected */;\\n    // TODO\\n    // detatch any event listeners that may have been added\\n    // because we\'re not passing an exact event name it\'ll\\n    // remove all of this element\'s event, which is good\\n    // create a callback for when this component finishes hmr\\n    elm[\'s-hmr-load\'] = () => {\\n        // finished hmr for this element\\n        delete elm[\'s-hmr-load\'];\\n    };\\n    // re-initialize the component\\n    initializeComponent(elm, hostRef, cmpMeta, hmrVersionId);\\n};\\nconst bootstrapLazy = (lazyBundles, options = {}) => {\\n    if (BUILD.profile && performance.mark) {\\n        performance.mark(\'st:app:start\');\\n    }\\n    installDevTools();\\n    const endBootstrap = createTime(\'bootstrapLazy\');\\n    const cmpTags = [];\\n    const exclude = options.exclude || [];\\n    const customElements = win.customElements;\\n    const head = doc.head;\\n    const metaCharset = /*@__PURE__*/ head.querySelector(\'meta[charset]\');\\n    const visibilityStyle = /*@__PURE__*/ doc.createElement(\'style\');\\n    const deferredConnectedCallbacks = [];\\n    const styles = /*@__PURE__*/ doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);\\n    let appLoadFallback;\\n    let isBootstrapping = true;\\n    let i = 0;\\n    Object.assign(plt, options);\\n    plt.$resourcesUrl$ = new URL(options.resourcesUrl || \'./\', doc.baseURI).href;\\n    if (BUILD.asyncQueue) {\\n        if (options.syncQueue) {\\n            plt.$flags$ |= 4 /* PLATFORM_FLAGS.queueSync */;\\n        }\\n    }\\n    if (BUILD.hydrateClientSide) {\\n        // If the app is already hydrated there is not point to disable the\\n        // async queue. This will improve the first input delay\\n        plt.$flags$ |= 2 /* PLATFORM_FLAGS.appLoaded */;\\n    }\\n    if (BUILD.hydrateClientSide && BUILD.shadowDom) {\\n        for (; i < styles.length; i++) {\\n            registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles[i].innerHTML), true);\\n        }\\n    }\\n    lazyBundles.map((lazyBundle) => {\\n        lazyBundle[1].map((compactMeta) => {\\n            const cmpMeta = {\\n                $flags$: compactMeta[0],\\n                $tagName$: compactMeta[1],\\n                $members$: compactMeta[2],\\n                $listeners$: compactMeta[3],\\n            };\\n            if (BUILD.member) {\\n                cmpMeta.$members$ = compactMeta[2];\\n            }\\n            if (BUILD.hostListener) {\\n                cmpMeta.$listeners$ = compactMeta[3];\\n            }\\n            if (BUILD.reflect) {\\n                cmpMeta.$attrsToReflect$ = [];\\n            }\\n            if (BUILD.watchCallback) {\\n                cmpMeta.$watchers$ = {};\\n            }\\n            if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {\\n                cmpMeta.$flags$ |= 8 /* CMP_FLAGS.needsShadowDomShim */;\\n            }\\n            const tagName = BUILD.transformTagName && options.transformTagName\\n                ? options.transformTagName(cmpMeta.$tagName$)\\n                : cmpMeta.$tagName$;\\n            const HostElement = class extends HTMLElement {\\n                // StencilLazyHost\\n                constructor(self) {\\n                    // @ts-ignore\\n                    super(self);\\n                    self = this;\\n                    registerHost(self, cmpMeta);\\n                    if (BUILD.shadowDom && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {\\n                        // this component is using shadow dom\\n                        // and this browser supports shadow dom\\n                        // add the read-only property \\"shadowRoot\\" to the host element\\n                        // adding the shadow root build conditionals to minimize runtime\\n                        if (supportsShadow) {\\n                            if (BUILD.shadowDelegatesFocus) {\\n                                self.attachShadow({\\n                                    mode: \'open\',\\n                                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* CMP_FLAGS.shadowDelegatesFocus */),\\n                                });\\n                            }\\n                            else {\\n                                self.attachShadow({ mode: \'open\' });\\n                            }\\n                        }\\n                        else if (!BUILD.hydrateServerSide && !(\'shadowRoot\' in self)) {\\n                            self.shadowRoot = self;\\n                        }\\n                    }\\n                    if (BUILD.slotChildNodesFix) {\\n                        patchChildSlotNodes(self, cmpMeta);\\n                    }\\n                }\\n                connectedCallback() {\\n                    if (appLoadFallback) {\\n                        clearTimeout(appLoadFallback);\\n                        appLoadFallback = null;\\n                    }\\n                    if (isBootstrapping) {\\n                        // connectedCallback will be processed once all components have been registered\\n                        deferredConnectedCallbacks.push(this);\\n                    }\\n                    else {\\n                        plt.jmp(() => connectedCallback(this));\\n                    }\\n                }\\n                disconnectedCallback() {\\n                    plt.jmp(() => disconnectedCallback(this));\\n                }\\n                componentOnReady() {\\n                    return getHostRef(this).$onReadyPromise$;\\n                }\\n            };\\n            if (BUILD.cloneNodeFix) {\\n                patchCloneNode(HostElement.prototype);\\n            }\\n            if (BUILD.appendChildSlotFix) {\\n                patchSlotAppendChild(HostElement.prototype);\\n            }\\n            if (BUILD.hotModuleReplacement) {\\n                HostElement.prototype[\'s-hmr\'] = function (hmrVersionId) {\\n                    hmrStart(this, cmpMeta, hmrVersionId);\\n                };\\n            }\\n            if (BUILD.scopedSlotTextContentFix) {\\n                patchTextContent(HostElement.prototype, cmpMeta);\\n            }\\n            cmpMeta.$lazyBundleId$ = lazyBundle[0];\\n            if (!exclude.includes(tagName) && !customElements.get(tagName)) {\\n                cmpTags.push(tagName);\\n                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* PROXY_FLAGS.isElementConstructor */));\\n            }\\n        });\\n    });\\n    if (BUILD.invisiblePrehydration && (BUILD.hydratedClass || BUILD.hydratedAttribute)) {\\n        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\\n        visibilityStyle.setAttribute(\'data-styles\', \'\');\\n        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\\n    }\\n    // Process deferred connectedCallbacks now all components have been registered\\n    isBootstrapping = false;\\n    if (deferredConnectedCallbacks.length) {\\n        deferredConnectedCallbacks.map((host) => host.connectedCallback());\\n    }\\n    else {\\n        if (BUILD.profile) {\\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30, \'timeout\')));\\n        }\\n        else {\\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));\\n        }\\n    }\\n    // Fallback appLoad event\\n    endBootstrap();\\n};\\nconst getConnect = (_ref, tagName) => {\\n    const componentOnReady = () => {\\n        let elm = doc.querySelector(tagName);\\n        if (!elm) {\\n            elm = doc.createElement(tagName);\\n            doc.body.appendChild(elm);\\n        }\\n        return typeof elm.componentOnReady === \'function\' ? elm.componentOnReady() : Promise.resolve(elm);\\n    };\\n    const create = (...args) => {\\n        return componentOnReady().then((el) => el.create(...args));\\n    };\\n    return {\\n        create,\\n        componentOnReady,\\n    };\\n};\\nconst getContext = (_elm, context) => {\\n    if (context in Context) {\\n        return Context[context];\\n    }\\n    else if (context === \'window\') {\\n        return win;\\n    }\\n    else if (context === \'document\') {\\n        return doc;\\n    }\\n    else if (context === \'isServer\' || context === \'isPrerender\') {\\n        return BUILD.hydrateServerSide ? true : false;\\n    }\\n    else if (context === \'isClient\') {\\n        return BUILD.hydrateServerSide ? false : true;\\n    }\\n    else if (context === \'resourcesUrl\' || context === \'publicPath\') {\\n        return getAssetPath(\'.\');\\n    }\\n    else if (context === \'queue\') {\\n        return {\\n            write: writeTask,\\n            read: readTask,\\n            tick: {\\n                then(cb) {\\n                    return nextTick(cb);\\n                },\\n            },\\n        };\\n    }\\n    return undefined;\\n};\\nconst Fragment = (_, children) => children;\\nconst addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {\\n    if (BUILD.hostListener && listeners) {\\n        // this is called immediately within the element\'s constructor\\n        // initialize our event listeners on the host element\\n        // we do this now so that we can listen to events that may\\n        // have fired even before the instance is ready\\n        if (BUILD.hostListenerTargetParent) {\\n            // this component may have event listeners that should be attached to the parent\\n            if (attachParentListeners) {\\n                // this is being ran from within the connectedCallback\\n                // which is important so that we know the host element actually has a parent element\\n                // filter out the listeners to only have the ones that ARE being attached to the parent\\n                listeners = listeners.filter(([flags]) => flags & 32 /* LISTENER_FLAGS.TargetParent */);\\n            }\\n            else {\\n                // this is being ran from within the component constructor\\n                // everything BUT the parent element listeners should be attached at this time\\n                // filter out the listeners that are NOT being attached to the parent\\n                listeners = listeners.filter(([flags]) => !(flags & 32 /* LISTENER_FLAGS.TargetParent */));\\n            }\\n        }\\n        listeners.map(([flags, name, method]) => {\\n            const target = BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;\\n            const handler = hostListenerProxy(hostRef, method);\\n            const opts = hostListenerOpts(flags);\\n            plt.ael(target, name, handler, opts);\\n            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));\\n        });\\n    }\\n};\\nconst hostListenerProxy = (hostRef, methodName) => (ev) => {\\n    try {\\n        if (BUILD.lazyLoad) {\\n            if (hostRef.$flags$ & 256 /* HOST_FLAGS.isListenReady */) {\\n                // instance is ready, let\'s call it\'s member method for this event\\n                hostRef.$lazyInstance$[methodName](ev);\\n            }\\n            else {\\n                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\\n            }\\n        }\\n        else {\\n            hostRef.$hostElement$[methodName](ev);\\n        }\\n    }\\n    catch (e) {\\n        consoleError(e);\\n    }\\n};\\nconst getHostListenerTarget = (elm, flags) => {\\n    if (BUILD.hostListenerTargetDocument && flags & 4 /* LISTENER_FLAGS.TargetDocument */)\\n        return doc;\\n    if (BUILD.hostListenerTargetWindow && flags & 8 /* LISTENER_FLAGS.TargetWindow */)\\n        return win;\\n    if (BUILD.hostListenerTargetBody && flags & 16 /* LISTENER_FLAGS.TargetBody */)\\n        return doc.body;\\n    if (BUILD.hostListenerTargetParent && flags & 32 /* LISTENER_FLAGS.TargetParent */)\\n        return elm.parentElement;\\n    return elm;\\n};\\n// prettier-ignore\\nconst hostListenerOpts = (flags) => supportsListenerOptions\\n    ? ({\\n        passive: (flags & 1 /* LISTENER_FLAGS.Passive */) !== 0,\\n        capture: (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0,\\n    })\\n    : (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0;\\nconst setPlatformOptions = (opts) => Object.assign(plt, opts);\\nconst insertVdomAnnotations = (doc, staticComponents) => {\\n    if (doc != null) {\\n        const docData = {\\n            hostIds: 0,\\n            rootLevelIds: 0,\\n            staticComponents: new Set(staticComponents),\\n        };\\n        const orgLocationNodes = [];\\n        parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);\\n        orgLocationNodes.forEach((orgLocationNode) => {\\n            if (orgLocationNode != null) {\\n                const nodeRef = orgLocationNode[\'s-nr\'];\\n                let hostId = nodeRef[\'s-host-id\'];\\n                let nodeId = nodeRef[\'s-node-id\'];\\n                let childId = `${hostId}.${nodeId}`;\\n                if (hostId == null) {\\n                    hostId = 0;\\n                    docData.rootLevelIds++;\\n                    nodeId = docData.rootLevelIds;\\n                    childId = `${hostId}.${nodeId}`;\\n                    if (nodeRef.nodeType === 1 /* NODE_TYPE.ElementNode */) {\\n                        nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);\\n                    }\\n                    else if (nodeRef.nodeType === 3 /* NODE_TYPE.TextNode */) {\\n                        if (hostId === 0) {\\n                            const textContent = nodeRef.nodeValue.trim();\\n                            if (textContent === \'\') {\\n                                // useless whitespace node at the document root\\n                                orgLocationNode.remove();\\n                                return;\\n                            }\\n                        }\\n                        const commentBeforeTextNode = doc.createComment(childId);\\n                        commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;\\n                        nodeRef.parentNode.insertBefore(commentBeforeTextNode, nodeRef);\\n                    }\\n                }\\n                let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;\\n                const orgLocationParentNode = orgLocationNode.parentElement;\\n                if (orgLocationParentNode) {\\n                    if (orgLocationParentNode[\'s-en\'] === \'\') {\\n                        // ending with a \\".\\" means that the parent element\\n                        // of this node\'s original location is a SHADOW dom element\\n                        // and this node is apart of the root level light dom\\n                        orgLocationNodeId += `.`;\\n                    }\\n                    else if (orgLocationParentNode[\'s-en\'] === \'c\') {\\n                        // ending with a \\".c\\" means that the parent element\\n                        // of this node\'s original location is a SCOPED element\\n                        // and this node is apart of the root level light dom\\n                        orgLocationNodeId += `.c`;\\n                    }\\n                }\\n                orgLocationNode.nodeValue = orgLocationNodeId;\\n            }\\n        });\\n    }\\n};\\nconst parseVNodeAnnotations = (doc, node, docData, orgLocationNodes) => {\\n    if (node == null) {\\n        return;\\n    }\\n    if (node[\'s-nr\'] != null) {\\n        orgLocationNodes.push(node);\\n    }\\n    if (node.nodeType === 1 /* NODE_TYPE.ElementNode */) {\\n        node.childNodes.forEach((childNode) => {\\n            const hostRef = getHostRef(childNode);\\n            if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {\\n                const cmpData = {\\n                    nodeIds: 0,\\n                };\\n                insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);\\n            }\\n            parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);\\n        });\\n    }\\n};\\nconst insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData) => {\\n    if (vnode != null) {\\n        const hostId = ++docData.hostIds;\\n        hostElm.setAttribute(HYDRATE_ID, hostId);\\n        if (hostElm[\'s-cr\'] != null) {\\n            hostElm[\'s-cr\'].nodeValue = `${CONTENT_REF_ID}.${hostId}`;\\n        }\\n        if (vnode.$children$ != null) {\\n            const depth = 0;\\n            vnode.$children$.forEach((vnodeChild, index) => {\\n                insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);\\n            });\\n        }\\n        if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute(\'c-id\')) {\\n            const parent = hostElm.parentElement;\\n            if (parent && parent.childNodes) {\\n                const parentChildNodes = Array.from(parent.childNodes);\\n                const comment = parentChildNodes.find((node) => node.nodeType === 8 /* NODE_TYPE.CommentNode */ && node[\'s-sr\']);\\n                if (comment) {\\n                    const index = parentChildNodes.indexOf(hostElm) - 1;\\n                    vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment[\'s-host-id\']}.${comment[\'s-node-id\']}.0.${index}`);\\n                }\\n            }\\n        }\\n    }\\n};\\nconst insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index) => {\\n    const childElm = vnodeChild.$elm$;\\n    if (childElm == null) {\\n        return;\\n    }\\n    const nodeId = cmpData.nodeIds++;\\n    const childId = `${hostId}.${nodeId}.${depth}.${index}`;\\n    childElm[\'s-host-id\'] = hostId;\\n    childElm[\'s-node-id\'] = nodeId;\\n    if (childElm.nodeType === 1 /* NODE_TYPE.ElementNode */) {\\n        childElm.setAttribute(HYDRATE_CHILD_ID, childId);\\n    }\\n    else if (childElm.nodeType === 3 /* NODE_TYPE.TextNode */) {\\n        const parentNode = childElm.parentNode;\\n        const nodeName = parentNode.nodeName;\\n        if (nodeName !== \'STYLE\' && nodeName !== \'SCRIPT\') {\\n            const textNodeId = `${TEXT_NODE_ID}.${childId}`;\\n            const commentBeforeTextNode = doc.createComment(textNodeId);\\n            parentNode.insertBefore(commentBeforeTextNode, childElm);\\n        }\\n    }\\n    else if (childElm.nodeType === 8 /* NODE_TYPE.CommentNode */) {\\n        if (childElm[\'s-sr\']) {\\n            const slotName = childElm[\'s-sn\'] || \'\';\\n            const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;\\n            childElm.nodeValue = slotNodeId;\\n        }\\n    }\\n    if (vnodeChild.$children$ != null) {\\n        const childDepth = depth + 1;\\n        vnodeChild.$children$.forEach((vnode, index) => {\\n            insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index);\\n        });\\n    }\\n};\\nconst hostRefs = /*@__PURE__*/ new WeakMap();\\nconst getHostRef = (ref) => hostRefs.get(ref);\\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);\\nconst registerHost = (elm, cmpMeta) => {\\n    const hostRef = {\\n        $flags$: 0,\\n        $hostElement$: elm,\\n        $cmpMeta$: cmpMeta,\\n        $instanceValues$: new Map(),\\n    };\\n    if (BUILD.isDev) {\\n        hostRef.$renderCount$ = 0;\\n    }\\n    if (BUILD.method && BUILD.lazyLoad) {\\n        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));\\n    }\\n    if (BUILD.asyncLoading) {\\n        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));\\n        elm[\'s-p\'] = [];\\n        elm[\'s-rc\'] = [];\\n    }\\n    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\\n    return hostRefs.set(elm, hostRef);\\n};\\nconst isMemberInElement = (elm, memberName) => memberName in elm;\\nconst consoleError = (e, el) => (customError || console.error)(e, el);\\nconst STENCIL_DEV_MODE = BUILD.isTesting\\n    ? [\'STENCIL:\'] // E2E testing\\n    : [\\n        \'%cstencil\',\\n        \'color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px\',\\n    ];\\nconst consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);\\nconst consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);\\nconst consoleDevInfo = (...m) => console.info(...STENCIL_DEV_MODE, ...m);\\nconst setErrorHandler = (handler) => (customError = handler);\\nconst cmpModules = /*@__PURE__*/ new Map();\\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\\n    // loadModuleImport\\n    const exportName = cmpMeta.$tagName$.replace(/-/g, \'_\');\\n    const bundleId = cmpMeta.$lazyBundleId$;\\n    if (BUILD.isDev && typeof bundleId !== \'string\') {\\n        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode \\"${hostRef.$modeName$}\\", but it does not exist.`);\\n        return undefined;\\n    }\\n    const module = !BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;\\n    if (module) {\\n        return module[exportName];\\n    }\\n    /*!__STENCIL_STATIC_IMPORT_SWITCH__*/\\n    return import(\\n    /* @vite-ignore */\\n    /* webpackInclude: /\\\\.entry\\\\.js$/ */\\n    /* webpackExclude: /\\\\.system\\\\.entry\\\\.js$/ */\\n    /* webpackMode: \\"lazy\\" */\\n    `./${bundleId}.entry.js${BUILD.hotModuleReplacement && hmrVersionId ? \'?s-hmr=\' + hmrVersionId : \'\'}`).then((importedModule) => {\\n        if (!BUILD.hotModuleReplacement) {\\n            cmpModules.set(bundleId, importedModule);\\n        }\\n        return importedModule[exportName];\\n    }, consoleError);\\n};\\nconst styles = /*@__PURE__*/ new Map();\\nconst modeResolutionChain = [];\\nconst win = typeof window !== \'undefined\' ? window : {};\\nconst CSS = BUILD.cssVarShim ? win.CSS : null;\\nconst doc = win.document || { head: {} };\\nconst H = (win.HTMLElement || class {\\n});\\nconst plt = {\\n    $flags$: 0,\\n    $resourcesUrl$: \'\',\\n    jmp: (h) => h(),\\n    raf: (h) => requestAnimationFrame(h),\\n    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\\n    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\\n    ce: (eventName, opts) => new CustomEvent(eventName, opts),\\n};\\nconst setPlatformHelpers = (helpers) => {\\n    Object.assign(plt, helpers);\\n};\\nconst supportsShadow = BUILD.shadowDomShim && BUILD.shadowDom\\n    ? /*@__PURE__*/ (() => (doc.head.attachShadow + \'\').indexOf(\'[native\') > -1)()\\n    : true;\\nconst supportsListenerOptions = /*@__PURE__*/ (() => {\\n    let supportsListenerOptions = false;\\n    try {\\n        doc.addEventListener(\'e\', null, Object.defineProperty({}, \'passive\', {\\n            get() {\\n                supportsListenerOptions = true;\\n            },\\n        }));\\n    }\\n    catch (e) { }\\n    return supportsListenerOptions;\\n})();\\nconst promiseResolve = (v) => Promise.resolve(v);\\nconst supportsConstructableStylesheets = BUILD.constructableCSS\\n    ? /*@__PURE__*/ (() => {\\n        try {\\n            new CSSStyleSheet();\\n            return typeof new CSSStyleSheet().replaceSync === \'function\';\\n        }\\n        catch (e) { }\\n        return false;\\n    })()\\n    : false;\\nconst queueDomReads = [];\\nconst queueDomWrites = [];\\nconst queueDomWritesLow = [];\\nconst queueTask = (queue, write) => (cb) => {\\n    queue.push(cb);\\n    if (!queuePending) {\\n        queuePending = true;\\n        if (write && plt.$flags$ & 4 /* PLATFORM_FLAGS.queueSync */) {\\n            nextTick(flush);\\n        }\\n        else {\\n            plt.raf(flush);\\n        }\\n    }\\n};\\nconst consume = (queue) => {\\n    for (let i = 0; i < queue.length; i++) {\\n        try {\\n            queue[i](performance.now());\\n        }\\n        catch (e) {\\n            consoleError(e);\\n        }\\n    }\\n    queue.length = 0;\\n};\\nconst consumeTimeout = (queue, timeout) => {\\n    let i = 0;\\n    let ts = 0;\\n    while (i < queue.length && (ts = performance.now()) < timeout) {\\n        try {\\n            queue[i++](ts);\\n        }\\n        catch (e) {\\n            consoleError(e);\\n        }\\n    }\\n    if (i === queue.length) {\\n        queue.length = 0;\\n    }\\n    else if (i !== 0) {\\n        queue.splice(0, i);\\n    }\\n};\\nconst flush = () => {\\n    if (BUILD.asyncQueue) {\\n        queueCongestion++;\\n    }\\n    // always force a bunch of medium callbacks to run, but still have\\n    // a throttle on how many can run in a certain time\\n    // DOM READS!!!\\n    consume(queueDomReads);\\n    // DOM WRITES!!!\\n    if (BUILD.asyncQueue) {\\n        const timeout = (plt.$flags$ & 6 /* PLATFORM_FLAGS.queueMask */) === 2 /* PLATFORM_FLAGS.appLoaded */\\n            ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0))\\n            : Infinity;\\n        consumeTimeout(queueDomWrites, timeout);\\n        consumeTimeout(queueDomWritesLow, timeout);\\n        if (queueDomWrites.length > 0) {\\n            queueDomWritesLow.push(...queueDomWrites);\\n            queueDomWrites.length = 0;\\n        }\\n        if ((queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0)) {\\n            // still more to do yet, but we\'ve run out of time\\n            // let\'s let this thing cool off and try again in the next tick\\n            plt.raf(flush);\\n        }\\n        else {\\n            queueCongestion = 0;\\n        }\\n    }\\n    else {\\n        consume(queueDomWrites);\\n        if ((queuePending = queueDomReads.length > 0)) {\\n            // still more to do yet, but we\'ve run out of time\\n            // let\'s let this thing cool off and try again in the next tick\\n            plt.raf(flush);\\n        }\\n    }\\n};\\nconst nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);\\nconst readTask = /*@__PURE__*/ queueTask(queueDomReads, false);\\nconst writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);\\nexport { BUILD, Env, NAMESPACE } from \'@stencil/core/internal/app-data\';\\nexport { Build, CSS, Context, Fragment, H, H as HTMLElement, Host, STENCIL_DEV_MODE, addHostEventListeners, bootstrapLazy, cmpModules, connectedCallback, consoleDevError, consoleDevInfo, consoleDevWarn, consoleError, createEvent, defineCustomElement, disconnectedCallback, doc, forceModeUpdate, forceUpdate, getAssetPath, getConnect, getContext, getElement, getHostRef, getMode, getRenderingRef, getValue, h, insertVdomAnnotations, isMemberInElement, loadModule, modeResolutionChain, nextTick, parsePropertyValue, plt, postUpdateComponent, promiseResolve, proxyComponent, proxyCustomElement, readTask, registerHost, registerInstance, renderVdom, setAssetPath, setErrorHandler, setMode, setPlatformHelpers, setPlatformOptions, setValue, styles, supportsConstructableStylesheets, supportsListenerOptions, supportsShadow, win, writeTask };\\n"]}')}}]);